import{O as Cn,V as I,Q as ut,R as zs,M as Ds,L as oi,C as q,B as V,a as $n,b as Vn,c as D,d as ge,e as Tt,T as Kt,S as ks,E as ri,f as it,P as ai,D as Qe,g as Ze,h as Rn,i as ot,j as ht,k as Q,l as pt,m as ci,n as Fs,o as jn,p as Ls,q as $t,r as li,s as ui,t as fi,u as hi,v as pi,W as di,w as mi,G as yi,x as gi,y as xi,z as Gn,H as wi}from"./index-CXNtdoUk.js";const Dt=new zs,j=new I,Pt=new I,U=new ut,qn={X:new I(1,0,0),Y:new I(0,1,0),Z:new I(0,0,1)},en={type:"change"},Yn={type:"mouseDown",mode:null},Qn={type:"mouseUp",mode:null},Zn={type:"objectChange"};class bi extends Cn{constructor(t,e){super(),e===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.isTransformControls=!0,this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const n=new vi;this._gizmo=n,this.add(n);const s=new Ci;this._plane=s,this.add(s);const r=this;function i(g,d){let y=d;Object.defineProperty(r,g,{get:function(){return y!==void 0?y:d},set:function(m){y!==m&&(y=m,s[g]=m,n[g]=m,r.dispatchEvent({type:g+"-changed",value:m}),r.dispatchEvent(en))}}),r[g]=d,s[g]=d,n[g]=d}i("camera",t),i("object",void 0),i("enabled",!0),i("axis",null),i("mode","translate"),i("translationSnap",null),i("rotationSnap",null),i("scaleSnap",null),i("space","world"),i("size",1),i("dragging",!1),i("showX",!0),i("showY",!0),i("showZ",!0);const c=new I,a=new I,f=new ut,l=new ut,h=new I,u=new ut,p=new I,S=new I,A=new I,w=0,x=new I;i("worldPosition",c),i("worldPositionStart",a),i("worldQuaternion",f),i("worldQuaternionStart",l),i("cameraPosition",h),i("cameraQuaternion",u),i("pointStart",p),i("pointEnd",S),i("rotationAxis",A),i("rotationAngle",w),i("eye",x),this._offset=new I,this._startNorm=new I,this._endNorm=new I,this._cameraScale=new I,this._parentPosition=new I,this._parentQuaternion=new ut,this._parentQuaternionInv=new ut,this._parentScale=new I,this._worldScaleStart=new I,this._worldQuaternionInv=new ut,this._worldScale=new I,this._positionStart=new I,this._quaternionStart=new ut,this._scaleStart=new I,this._getPointer=Si.bind(this),this._onPointerDown=Ti.bind(this),this._onPointerHover=Ai.bind(this),this._onPointerMove=Pi.bind(this),this._onPointerUp=_i.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(t){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(t)}pointerHover(t){if(this.object===void 0||this.dragging===!0)return;t!==null&&Dt.setFromCamera(t,this.camera);const e=nn(this._gizmo.picker[this.mode],Dt);e?this.axis=e.object.name:this.axis=null}pointerDown(t){if(!(this.object===void 0||this.dragging===!0||t!=null&&t.button!==0)&&this.axis!==null){t!==null&&Dt.setFromCamera(t,this.camera);const e=nn(this._plane,Dt,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,Yn.mode=this.mode,this.dispatchEvent(Yn)}}pointerMove(t){const e=this.axis,n=this.mode,s=this.object;let r=this.space;if(n==="scale"?r="local":(e==="E"||e==="XYZE"||e==="XYZ")&&(r="world"),s===void 0||e===null||this.dragging===!1||t!==null&&t.button!==-1)return;t!==null&&Dt.setFromCamera(t,this.camera);const i=nn(this._plane,Dt,!0);if(i){if(this.pointEnd.copy(i.point).sub(this.worldPositionStart),n==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&e!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),e.indexOf("X")===-1&&(this._offset.x=0),e.indexOf("Y")===-1&&(this._offset.y=0),e.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&e!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),s.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(s.position.applyQuaternion(U.copy(this._quaternionStart).invert()),e.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.position.applyQuaternion(this._quaternionStart)),r==="world"&&(s.parent&&s.position.add(j.setFromMatrixPosition(s.parent.matrixWorld)),e.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),e.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),e.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.parent&&s.position.sub(j.setFromMatrixPosition(s.parent.matrixWorld))));else if(n==="scale"){if(e.search("XYZ")!==-1){let c=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(c*=-1),Pt.set(c,c,c)}else j.copy(this.pointStart),Pt.copy(this.pointEnd),j.applyQuaternion(this._worldQuaternionInv),Pt.applyQuaternion(this._worldQuaternionInv),Pt.divide(j),e.search("X")===-1&&(Pt.x=1),e.search("Y")===-1&&(Pt.y=1),e.search("Z")===-1&&(Pt.z=1);s.scale.copy(this._scaleStart).multiply(Pt),this.scaleSnap&&(e.search("X")!==-1&&(s.scale.x=Math.round(s.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Y")!==-1&&(s.scale.y=Math.round(s.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),e.search("Z")!==-1&&(s.scale.z=Math.round(s.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(n==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const c=20/this.worldPosition.distanceTo(j.setFromMatrixPosition(this.camera.matrixWorld));let a=!1;e==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(j.copy(this.rotationAxis).cross(this.eye))*c):(e==="X"||e==="Y"||e==="Z")&&(this.rotationAxis.copy(qn[e]),j.copy(qn[e]),r==="local"&&j.applyQuaternion(this.worldQuaternion),j.cross(this.eye),j.length()===0?a=!0:this.rotationAngle=this._offset.dot(j.normalize())*c),(e==="E"||a)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&e!=="E"&&e!=="XYZE"?(s.quaternion.copy(this._quaternionStart),s.quaternion.multiply(U.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),s.quaternion.copy(U.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),s.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(en),this.dispatchEvent(Zn)}}pointerUp(t){t!==null&&t.button!==0||(this.dragging&&this.axis!==null&&(Qn.mode=this.mode,this.dispatchEvent(Qn)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()})}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(en),this.dispatchEvent(Zn),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Dt}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}}function Si(o){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:o.button};{const t=this.domElement.getBoundingClientRect();return{x:(o.clientX-t.left)/t.width*2-1,y:-(o.clientY-t.top)/t.height*2+1,button:o.button}}}function Ai(o){if(this.enabled)switch(o.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(o));break}}function Ti(o){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(o.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(o)),this.pointerDown(this._getPointer(o)))}function Pi(o){this.enabled&&this.pointerMove(this._getPointer(o))}function _i(o){this.enabled&&(this.domElement.releasePointerCapture(o.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(o)))}function nn(o,t,e){const n=t.intersectObject(o,!0);for(let s=0;s<n.length;s++)if(n[s].object.visible||e)return n[s];return!1}const xe=new ri,L=new I(0,1,0),Wn=new I(0,0,0),Kn=new it,we=new ut,Oe=new ut,lt=new I,Jn=new it,ue=new I(1,0,0),Ut=new I(0,1,0),fe=new I(0,0,1),be=new I,te=new I,ee=new I;class vi extends Cn{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const t=new Ds({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new oi({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),n=t.clone();n.opacity=.15;const s=e.clone();s.opacity=.5;const r=t.clone();r.color.setHex(16711680);const i=t.clone();i.color.setHex(65280);const c=t.clone();c.color.setHex(255);const a=t.clone();a.color.setHex(16711680),a.opacity=.5;const f=t.clone();f.color.setHex(65280),f.opacity=.5;const l=t.clone();l.color.setHex(255),l.opacity=.5;const h=t.clone();h.opacity=.25;const u=t.clone();u.color.setHex(16776960),u.opacity=.25,t.clone().color.setHex(16776960);const S=t.clone();S.color.setHex(7895160);const A=new q(0,.04,.1,12);A.translate(0,.05,0);const w=new V(.08,.08,.08);w.translate(0,.04,0);const x=new $n;x.setAttribute("position",new Vn([0,0,0,1,0,0],3));const g=new q(.0075,.0075,.5,3);g.translate(0,.25,0);function d(z,k){const F=new Kt(z,.0075,3,64,k*Math.PI*2);return F.rotateY(Math.PI/2),F.rotateX(Math.PI/2),F}function y(){const z=new $n;return z.setAttribute("position",new Vn([0,0,0,1,1,1],3)),z}const m={X:[[new D(A,r),[.5,0,0],[0,0,-Math.PI/2]],[new D(A,r),[-.5,0,0],[0,0,Math.PI/2]],[new D(g,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new D(A,i),[0,.5,0]],[new D(A,i),[0,-.5,0],[Math.PI,0,0]],[new D(g,i)]],Z:[[new D(A,c),[0,0,.5],[Math.PI/2,0,0]],[new D(A,c),[0,0,-.5],[-Math.PI/2,0,0]],[new D(g,c),null,[Math.PI/2,0,0]]],XYZ:[[new D(new ge(.1,0),h.clone()),[0,0,0]]],XY:[[new D(new V(.15,.15,.01),l.clone()),[.15,.15,0]]],YZ:[[new D(new V(.15,.15,.01),a.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new D(new V(.15,.15,.01),f.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},T={X:[[new D(new q(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new D(new q(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new D(new q(.2,0,.6,4),n),[0,.3,0]],[new D(new q(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new D(new q(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new D(new q(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new D(new ge(.2,0),n)]],XY:[[new D(new V(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new D(new V(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new D(new V(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]]},b={START:[[new D(new ge(.01,2),s),null,null,null,"helper"]],END:[[new D(new ge(.01,2),s),null,null,null,"helper"]],DELTA:[[new Tt(y(),s),null,null,null,"helper"]],X:[[new Tt(x,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Tt(x,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Tt(x,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},P={XYZE:[[new D(d(.5,1),S),null,[0,Math.PI/2,0]]],X:[[new D(d(.5,.5),r)]],Y:[[new D(d(.5,.5),i),null,[0,0,-Math.PI/2]]],Z:[[new D(d(.5,.5),c),null,[0,Math.PI/2,0]]],E:[[new D(d(.75,1),u),null,[0,Math.PI/2,0]]]},_={AXIS:[[new Tt(x,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},M={XYZE:[[new D(new ks(.25,10,8),n)]],X:[[new D(new Kt(.5,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new D(new Kt(.5,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new D(new Kt(.5,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new D(new Kt(.75,.1,2,24),n)]]},E={X:[[new D(w,r),[.5,0,0],[0,0,-Math.PI/2]],[new D(g,r),[0,0,0],[0,0,-Math.PI/2]],[new D(w,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new D(w,i),[0,.5,0]],[new D(g,i)],[new D(w,i),[0,-.5,0],[0,0,Math.PI]]],Z:[[new D(w,c),[0,0,.5],[Math.PI/2,0,0]],[new D(g,c),[0,0,0],[Math.PI/2,0,0]],[new D(w,c),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new D(new V(.15,.15,.01),l),[.15,.15,0]]],YZ:[[new D(new V(.15,.15,.01),a),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new D(new V(.15,.15,.01),f),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new D(new V(.1,.1,.1),h.clone())]]},v={X:[[new D(new q(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new D(new q(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new D(new q(.2,0,.6,4),n),[0,.3,0]],[new D(new q(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new D(new q(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new D(new q(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new D(new V(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new D(new V(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new D(new V(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new D(new V(.2,.2,.2),n),[0,0,0]]]},C={X:[[new Tt(x,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new Tt(x,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new Tt(x,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function B(z){const k=new Cn;for(const F in z)for(let $=z[F].length;$--;){const R=z[F][$][0].clone(),bt=z[F][$][1],St=z[F][$][2],At=z[F][$][3],ye=z[F][$][4];R.name=F,R.tag=ye,bt&&R.position.set(bt[0],bt[1],bt[2]),St&&R.rotation.set(St[0],St[1],St[2]),At&&R.scale.set(At[0],At[1],At[2]),R.updateMatrix();const Je=R.geometry.clone();Je.applyMatrix4(R.matrix),R.geometry=Je,R.renderOrder=1/0,R.position.set(0,0,0),R.rotation.set(0,0,0),R.scale.set(1,1,1),k.add(R)}return k}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=B(m)),this.add(this.gizmo.rotate=B(P)),this.add(this.gizmo.scale=B(E)),this.add(this.picker.translate=B(T)),this.add(this.picker.rotate=B(M)),this.add(this.picker.scale=B(v)),this.add(this.helper.translate=B(b)),this.add(this.helper.rotate=B(_)),this.add(this.helper.scale=B(C)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const n=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:Oe;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let s=[];s=s.concat(this.picker[this.mode].children),s=s.concat(this.gizmo[this.mode].children),s=s.concat(this.helper[this.mode].children);for(let r=0;r<s.length;r++){const i=s[r];i.visible=!0,i.rotation.set(0,0,0),i.position.copy(this.worldPosition);let c;if(this.camera.isOrthographicCamera?c=(this.camera.top-this.camera.bottom)/this.camera.zoom:c=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),i.scale.set(1,1,1).multiplyScalar(c*this.size/4),i.tag==="helper"){i.visible=!1,i.name==="AXIS"?(i.visible=!!this.axis,this.axis==="X"&&(U.setFromEuler(xe.set(0,0,0)),i.quaternion.copy(n).multiply(U),Math.abs(L.copy(ue).applyQuaternion(n).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="Y"&&(U.setFromEuler(xe.set(0,0,Math.PI/2)),i.quaternion.copy(n).multiply(U),Math.abs(L.copy(Ut).applyQuaternion(n).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="Z"&&(U.setFromEuler(xe.set(0,Math.PI/2,0)),i.quaternion.copy(n).multiply(U),Math.abs(L.copy(fe).applyQuaternion(n).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="XYZE"&&(U.setFromEuler(xe.set(0,Math.PI/2,0)),L.copy(this.rotationAxis),i.quaternion.setFromRotationMatrix(Kn.lookAt(Wn,L,Ut)),i.quaternion.multiply(U),i.visible=this.dragging),this.axis==="E"&&(i.visible=!1)):i.name==="START"?(i.position.copy(this.worldPositionStart),i.visible=this.dragging):i.name==="END"?(i.position.copy(this.worldPosition),i.visible=this.dragging):i.name==="DELTA"?(i.position.copy(this.worldPositionStart),i.quaternion.copy(this.worldQuaternionStart),j.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),j.applyQuaternion(this.worldQuaternionStart.clone().invert()),i.scale.copy(j),i.visible=this.dragging):(i.quaternion.copy(n),this.dragging?i.position.copy(this.worldPositionStart):i.position.copy(this.worldPosition),this.axis&&(i.visible=this.axis.search(i.name)!==-1));continue}i.quaternion.copy(n),this.mode==="translate"||this.mode==="scale"?(i.name==="X"&&Math.abs(L.copy(ue).applyQuaternion(n).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="Y"&&Math.abs(L.copy(Ut).applyQuaternion(n).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="Z"&&Math.abs(L.copy(fe).applyQuaternion(n).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="XY"&&Math.abs(L.copy(fe).applyQuaternion(n).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="YZ"&&Math.abs(L.copy(ue).applyQuaternion(n).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="XZ"&&Math.abs(L.copy(Ut).applyQuaternion(n).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1)):this.mode==="rotate"&&(we.copy(n),L.copy(this.eye).applyQuaternion(U.copy(n).invert()),i.name.search("E")!==-1&&i.quaternion.setFromRotationMatrix(Kn.lookAt(this.eye,Wn,Ut)),i.name==="X"&&(U.setFromAxisAngle(ue,Math.atan2(-L.y,L.z)),U.multiplyQuaternions(we,U),i.quaternion.copy(U)),i.name==="Y"&&(U.setFromAxisAngle(Ut,Math.atan2(L.x,L.z)),U.multiplyQuaternions(we,U),i.quaternion.copy(U)),i.name==="Z"&&(U.setFromAxisAngle(fe,Math.atan2(L.y,L.x)),U.multiplyQuaternions(we,U),i.quaternion.copy(U))),i.visible=i.visible&&(i.name.indexOf("X")===-1||this.showX),i.visible=i.visible&&(i.name.indexOf("Y")===-1||this.showY),i.visible=i.visible&&(i.name.indexOf("Z")===-1||this.showZ),i.visible=i.visible&&(i.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),i.material._color=i.material._color||i.material.color.clone(),i.material._opacity=i.material._opacity||i.material.opacity,i.material.color.copy(i.material._color),i.material.opacity=i.material._opacity,this.enabled&&this.axis&&(i.name===this.axis||this.axis.split("").some(function(a){return i.name===a}))&&(i.material.color.setHex(16776960),i.material.opacity=1)}super.updateMatrixWorld(t)}}class Ci extends D{constructor(){super(new ai(1e5,1e5,2,2),new Ds({visible:!1,wireframe:!0,side:Qe,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),be.copy(ue).applyQuaternion(e==="local"?this.worldQuaternion:Oe),te.copy(Ut).applyQuaternion(e==="local"?this.worldQuaternion:Oe),ee.copy(fe).applyQuaternion(e==="local"?this.worldQuaternion:Oe),L.copy(te),this.mode){case"translate":case"scale":switch(this.axis){case"X":L.copy(this.eye).cross(be),lt.copy(be).cross(L);break;case"Y":L.copy(this.eye).cross(te),lt.copy(te).cross(L);break;case"Z":L.copy(this.eye).cross(ee),lt.copy(ee).cross(L);break;case"XY":lt.copy(ee);break;case"YZ":lt.copy(be);break;case"XZ":L.copy(ee),lt.copy(te);break;case"XYZ":case"E":lt.set(0,0,0);break}break;case"rotate":default:lt.set(0,0,0)}lt.length()===0?this.quaternion.copy(this.cameraQuaternion):(Jn.lookAt(j.set(0,0,0),lt,L),this.quaternion.setFromRotationMatrix(Jn)),super.updateMatrixWorld(t)}}const Rs=0,Mi=1,Ei=2,ts=2,sn=1.25,es=1,pe=6*4+4+4,We=65535,Ii=Math.pow(2,-24),on=Symbol("SKIP_GENERATION");function Bi(o){return o.index?o.index.count:o.attributes.position.count}function zt(o){return Bi(o)/3}function zi(o,t=ArrayBuffer){return o>65535?new Uint32Array(new t(4*o)):new Uint16Array(new t(2*o))}function Di(o,t){if(!o.index){const e=o.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=zi(e,n);o.setIndex(new Ze(s,1));for(let r=0;r<e;r++)s[r]=r}}function Ns(o,t){const e=zt(o),n=t||o.drawRange,s=n.start/3,r=(n.start+n.count)/3,i=Math.max(0,s),c=Math.min(e,r)-i;return[{offset:Math.floor(i),count:Math.floor(c)}]}function Us(o,t){if(!o.groups||!o.groups.length)return Ns(o,t);const e=[],n=new Set,s=t||o.drawRange,r=s.start/3,i=(s.start+s.count)/3;for(const a of o.groups){const f=a.start/3,l=(a.start+a.count)/3;n.add(Math.max(r,f)),n.add(Math.min(i,l))}const c=Array.from(n.values()).sort((a,f)=>a-f);for(let a=0;a<c.length-1;a++){const f=c[a],l=c[a+1];e.push({offset:Math.floor(f),count:Math.floor(l-f)})}return e}function ki(o,t){const e=zt(o),n=Us(o,t).sort((i,c)=>i.offset-c.offset),s=n[n.length-1];s.count=Math.min(e-s.offset,s.count);let r=0;return n.forEach(({count:i})=>r+=i),e!==r}function rn(o,t,e,n,s){let r=1/0,i=1/0,c=1/0,a=-1/0,f=-1/0,l=-1/0,h=1/0,u=1/0,p=1/0,S=-1/0,A=-1/0,w=-1/0;for(let x=t*6,g=(t+e)*6;x<g;x+=6){const d=o[x+0],y=o[x+1],m=d-y,T=d+y;m<r&&(r=m),T>a&&(a=T),d<h&&(h=d),d>S&&(S=d);const b=o[x+2],P=o[x+3],_=b-P,M=b+P;_<i&&(i=_),M>f&&(f=M),b<u&&(u=b),b>A&&(A=b);const E=o[x+4],v=o[x+5],C=E-v,B=E+v;C<c&&(c=C),B>l&&(l=B),E<p&&(p=E),E>w&&(w=E)}n[0]=r,n[1]=i,n[2]=c,n[3]=a,n[4]=f,n[5]=l,s[0]=h,s[1]=u,s[2]=p,s[3]=S,s[4]=A,s[5]=w}function Fi(o,t=null,e=null,n=null){const s=o.attributes.position,r=o.index?o.index.array:null,i=zt(o),c=s.normalized;let a;t===null?a=new Float32Array(i*6):a=t,e=e||0,n=n||i;const f=s.array,l=s.offset||0;let h=3;s.isInterleavedBufferAttribute&&(h=s.data.stride);const u=["getX","getY","getZ"];for(let p=e;p<e+n;p++){const S=p*3,A=p*6;let w=S+0,x=S+1,g=S+2;r&&(w=r[w],x=r[x],g=r[g]),c||(w=w*h+l,x=x*h+l,g=g*h+l);for(let d=0;d<3;d++){let y,m,T;c?(y=s[u[d]](w),m=s[u[d]](x),T=s[u[d]](g)):(y=f[w+d],m=f[x+d],T=f[g+d]);let b=y;m<b&&(b=m),T<b&&(b=T);let P=y;m>P&&(P=m),T>P&&(P=T);const _=(P-b)/2,M=d*2;a[A+M+0]=b+_,a[A+M+1]=_+(Math.abs(b)+_)*Ii}}return a}function H(o,t,e){return e.min.x=t[o],e.min.y=t[o+1],e.min.z=t[o+2],e.max.x=t[o+3],e.max.y=t[o+4],e.max.z=t[o+5],e}function ns(o){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=o[n+3]-o[n];s>e&&(e=s,t=n)}return t}function ss(o,t){t.set(o)}function is(o,t,e){let n,s;for(let r=0;r<3;r++){const i=r+3;n=o[r],s=t[r],e[r]=n<s?n:s,n=o[i],s=t[i],e[i]=n>s?n:s}}function Se(o,t,e){for(let n=0;n<3;n++){const s=t[o+2*n],r=t[o+2*n+1],i=s-r,c=s+r;i<e[n]&&(e[n]=i),c>e[n+3]&&(e[n+3]=c)}}function ne(o){const t=o[3]-o[0],e=o[4]-o[1],n=o[5]-o[2];return 2*(t*e+e*n+n*t)}const gt=32,Li=(o,t)=>o.candidate-t.candidate,_t=new Array(gt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ae=new Float32Array(6);function Ri(o,t,e,n,s,r){let i=-1,c=0;if(r===Rs)i=ns(t),i!==-1&&(c=(t[i]+t[i+3])/2);else if(r===Mi)i=ns(o),i!==-1&&(c=Ni(e,n,s,i));else if(r===Ei){const a=ne(o);let f=sn*s;const l=n*6,h=(n+s)*6;for(let u=0;u<3;u++){const p=t[u],w=(t[u+3]-p)/gt;if(s<gt/4){const x=[..._t];x.length=s;let g=0;for(let y=l;y<h;y+=6,g++){const m=x[g];m.candidate=e[y+2*u],m.count=0;const{bounds:T,leftCacheBounds:b,rightCacheBounds:P}=m;for(let _=0;_<3;_++)P[_]=1/0,P[_+3]=-1/0,b[_]=1/0,b[_+3]=-1/0,T[_]=1/0,T[_+3]=-1/0;Se(y,e,T)}x.sort(Li);let d=s;for(let y=0;y<d;y++){const m=x[y];for(;y+1<d&&x[y+1].candidate===m.candidate;)x.splice(y+1,1),d--}for(let y=l;y<h;y+=6){const m=e[y+2*u];for(let T=0;T<d;T++){const b=x[T];m>=b.candidate?Se(y,e,b.rightCacheBounds):(Se(y,e,b.leftCacheBounds),b.count++)}}for(let y=0;y<d;y++){const m=x[y],T=m.count,b=s-m.count,P=m.leftCacheBounds,_=m.rightCacheBounds;let M=0;T!==0&&(M=ne(P)/a);let E=0;b!==0&&(E=ne(_)/a);const v=es+sn*(M*T+E*b);v<f&&(i=u,f=v,c=m.candidate)}}else{for(let d=0;d<gt;d++){const y=_t[d];y.count=0,y.candidate=p+w+d*w;const m=y.bounds;for(let T=0;T<3;T++)m[T]=1/0,m[T+3]=-1/0}for(let d=l;d<h;d+=6){let T=~~((e[d+2*u]-p)/w);T>=gt&&(T=gt-1);const b=_t[T];b.count++,Se(d,e,b.bounds)}const x=_t[gt-1];ss(x.bounds,x.rightCacheBounds);for(let d=gt-2;d>=0;d--){const y=_t[d],m=_t[d+1];is(y.bounds,m.rightCacheBounds,y.rightCacheBounds)}let g=0;for(let d=0;d<gt-1;d++){const y=_t[d],m=y.count,T=y.bounds,P=_t[d+1].rightCacheBounds;m!==0&&(g===0?ss(T,Ae):is(T,Ae,Ae)),g+=m;let _=0,M=0;g!==0&&(_=ne(Ae)/a);const E=s-g;E!==0&&(M=ne(P)/a);const v=es+sn*(_*g+M*E);v<f&&(i=u,f=v,c=y.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:i,pos:c}}function Ni(o,t,e,n){let s=0;for(let r=t,i=t+e;r<i;r++)s+=o[r*6+n*2];return s/e}class an{constructor(){this.boundingData=new Float32Array(6)}}function Ui(o,t,e,n,s,r){let i=n,c=n+s-1;const a=r.pos,f=r.axis*2;for(;;){for(;i<=c&&e[i*6+f]<a;)i++;for(;i<=c&&e[c*6+f]>=a;)c--;if(i<c){for(let l=0;l<3;l++){let h=t[i*3+l];t[i*3+l]=t[c*3+l],t[c*3+l]=h}for(let l=0;l<6;l++){let h=e[i*6+l];e[i*6+l]=e[c*6+l],e[c*6+l]=h}i++,c--}else return i}}function Hi(o,t,e,n,s,r){let i=n,c=n+s-1;const a=r.pos,f=r.axis*2;for(;;){for(;i<=c&&e[i*6+f]<a;)i++;for(;i<=c&&e[c*6+f]>=a;)c--;if(i<c){let l=o[i];o[i]=o[c],o[c]=l;for(let h=0;h<6;h++){let u=e[i*6+h];e[i*6+h]=e[c*6+h],e[c*6+h]=u}i++,c--}else return i}}function Z(o,t){return t[o+15]===65535}function W(o,t){return t[o+6]}function tt(o,t){return t[o+14]}function et(o){return o+8}function nt(o,t){return t[o+6]}function Hs(o,t){return t[o+7]}let Os,he,Xe,Xs;const Oi=Math.pow(2,32);function Mn(o){return"count"in o?1:1+Mn(o.left)+Mn(o.right)}function Xi(o,t,e){return Os=new Float32Array(e),he=new Uint32Array(e),Xe=new Uint16Array(e),Xs=new Uint8Array(e),En(o,t)}function En(o,t){const e=o/4,n=o/2,s="count"in t,r=t.boundingData;for(let i=0;i<6;i++)Os[e+i]=r[i];if(s)if(t.buffer){const i=t.buffer;Xs.set(new Uint8Array(i),o);for(let c=o,a=o+i.byteLength;c<a;c+=pe){const f=c/2;Z(f,Xe)||(he[c/4+6]+=e)}return o+i.byteLength}else{const i=t.offset,c=t.count;return he[e+6]=i,Xe[n+14]=c,Xe[n+15]=We,o+pe}else{const i=t.left,c=t.right,a=t.splitAxis;let f;if(f=En(o+pe,i),f/4>Oi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return he[e+6]=f/4,f=En(f,c),he[e+7]=a,f}}function $i(o,t){const e=(o.index?o.index.count:o.attributes.position.count)/3,n=e>2**16,s=n?4:2,r=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),i=n?new Uint32Array(r):new Uint16Array(r);for(let c=0,a=i.length;c<a;c++)i[c]=c;return i}function Vi(o,t,e,n,s){const{maxDepth:r,verbose:i,maxLeafTris:c,strategy:a,onProgress:f,indirect:l}=s,h=o._indirectBuffer,u=o.geometry,p=u.index?u.index.array:null,S=l?Hi:Ui,A=zt(u),w=new Float32Array(6);let x=!1;const g=new an;return rn(t,e,n,g.boundingData,w),y(g,e,n,w),g;function d(m){f&&f(m/A)}function y(m,T,b,P=null,_=0){if(!x&&_>=r&&(x=!0,i&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),b<=c||_>=r)return d(T+b),m.offset=T,m.count=b,m;const M=Ri(m.boundingData,P,t,T,b,a);if(M.axis===-1)return d(T+b),m.offset=T,m.count=b,m;const E=S(h,p,t,T,b,M);if(E===T||E===T+b)d(T+b),m.offset=T,m.count=b;else{m.splitAxis=M.axis;const v=new an,C=T,B=E-T;m.left=v,rn(t,C,B,v.boundingData,w),y(v,C,B,w,_+1);const z=new an,k=E,F=b-B;m.right=z,rn(t,k,F,z.boundingData,w),y(z,k,F,w,_+1)}return m}}function ji(o,t){const e=o.geometry;t.indirect&&(o._indirectBuffer=$i(e,t.useSharedArrayBuffer),ki(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),o._indirectBuffer||Di(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ns(e,t.range),r=Fi(e,null,s[0].offset,s[0].count),i=t.indirect?s:Us(e,t.range);o._roots=i.map(c=>{const a=Vi(o,r,c.offset,c.count,t),f=Mn(a),l=new n(pe*f);return Xi(0,a,l),l})}class wt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let r=0,i=t.length;r<i;r++){const a=t[r][e];n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let r=0,i=e.length;r<i;r++){const c=e[r],a=t.dot(c);n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}wt.prototype.setFromBox=function(){const o=new I;return function(e,n){const s=n.min,r=n.max;let i=1/0,c=-1/0;for(let a=0;a<=1;a++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){o.x=s.x*a+r.x*(1-a),o.y=s.y*f+r.y*(1-f),o.z=s.z*l+r.z*(1-l);const h=e.dot(o);i=Math.min(h,i),c=Math.max(h,c)}this.min=i,this.max=c}}();const Gi=function(){const o=new I,t=new I,e=new I;return function(s,r,i){const c=s.start,a=o,f=r.start,l=t;e.subVectors(c,f),o.subVectors(s.end,s.start),t.subVectors(r.end,r.start);const h=e.dot(l),u=l.dot(a),p=l.dot(l),S=e.dot(a),w=a.dot(a)*p-u*u;let x,g;w!==0?x=(h*u-S*p)/w:x=0,g=(h+x*u)/p,i.x=x,i.y=g}}(),Nn=function(){const o=new ht,t=new I,e=new I;return function(s,r,i,c){Gi(s,r,o);let a=o.x,f=o.y;if(a>=0&&a<=1&&f>=0&&f<=1){s.at(a,i),r.at(f,c);return}else if(a>=0&&a<=1){f<0?r.at(0,c):r.at(1,c),s.closestPointToPoint(c,!0,i);return}else if(f>=0&&f<=1){a<0?s.at(0,i):s.at(1,i),r.closestPointToPoint(i,!0,c);return}else{let l;a<0?l=s.start:l=s.end;let h;f<0?h=r.start:h=r.end;const u=t,p=e;if(s.closestPointToPoint(h,!0,t),r.closestPointToPoint(l,!0,e),u.distanceToSquared(h)<=p.distanceToSquared(l)){i.copy(u),c.copy(h);return}else{i.copy(l),c.copy(p);return}}}}(),qi=function(){const o=new I,t=new I,e=new Rn,n=new ot;return function(r,i){const{radius:c,center:a}=r,{a:f,b:l,c:h}=i;if(n.start=f,n.end=l,n.closestPointToPoint(a,!0,o).distanceTo(a)<=c||(n.start=f,n.end=h,n.closestPointToPoint(a,!0,o).distanceTo(a)<=c)||(n.start=l,n.end=h,n.closestPointToPoint(a,!0,o).distanceTo(a)<=c))return!0;const A=i.getPlane(e);if(Math.abs(A.distanceToPoint(a))<=c){const x=A.projectPoint(a,t);if(i.containsPoint(x))return!0}return!1}}(),Yi=["x","y","z"],xt=1e-15,os=xt*xt;function K(o){return Math.abs(o)<xt}class rt extends Q{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new wt),this.points=[this.a,this.b,this.c],this.plane=new Rn,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new ot,this.needsUpdate=!0}intersectsSphere(t){return qi(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,r=this.satAxes,i=this.satBounds,c=r[0],a=i[0];this.getNormal(c),a.setFromPoints(c,s);const f=r[1],l=i[1];f.subVectors(t,e),l.setFromPoints(f,s);const h=r[2],u=i[2];h.subVectors(e,n),u.setFromPoints(h,s);const p=r[3],S=i[3];p.subVectors(n,t),S.setFromPoints(p,s);const A=f.length(),w=h.length(),x=p.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,A<xt?w<xt||x<xt?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(n)):w<xt?x<xt?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(e),this.degenerateSegment.end.copy(t)):x<xt&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(e)),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}rt.prototype.closestPointToSegment=function(){const o=new I,t=new I,e=new ot;return function(s,r=null,i=null){const{start:c,end:a}=s,f=this.points;let l,h=1/0;for(let u=0;u<3;u++){const p=(u+1)%3;e.start.copy(f[u]),e.end.copy(f[p]),Nn(e,s,o,t),l=o.distanceToSquared(t),l<h&&(h=l,r&&r.copy(o),i&&i.copy(t))}return this.closestPointToPoint(c,o),l=c.distanceToSquared(o),l<h&&(h=l,r&&r.copy(o),i&&i.copy(c)),this.closestPointToPoint(a,o),l=a.distanceToSquared(o),l<h&&(h=l,r&&r.copy(o),i&&i.copy(a)),Math.sqrt(h)}}();rt.prototype.intersectsTriangle=function(){const o=new rt,t=new wt,e=new wt,n=new I,s=new I,r=new I,i=new I,c=new ot,a=new ot,f=new I,l=new ht,h=new ht;function u(d,y,m,T){const b=n;!d.isDegenerateIntoPoint&&!d.isDegenerateIntoSegment?b.copy(d.plane.normal):b.copy(y.plane.normal);const P=d.satBounds,_=d.satAxes;for(let v=1;v<4;v++){const C=P[v],B=_[v];if(t.setFromPoints(B,y.points),C.isSeparated(t)||(i.copy(b).cross(B),t.setFromPoints(i,d.points),e.setFromPoints(i,y.points),t.isSeparated(e)))return!1}const M=y.satBounds,E=y.satAxes;for(let v=1;v<4;v++){const C=M[v],B=E[v];if(t.setFromPoints(B,d.points),C.isSeparated(t)||(i.crossVectors(b,B),t.setFromPoints(i,d.points),e.setFromPoints(i,y.points),t.isSeparated(e)))return!1}return m&&(T||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}function p(d,y,m,T,b,P,_,M,E,v,C){let B=_/(_-M);v.x=T+(b-T)*B,C.start.subVectors(y,d).multiplyScalar(B).add(d),B=_/(_-E),v.y=T+(P-T)*B,C.end.subVectors(m,d).multiplyScalar(B).add(d)}function S(d,y,m,T,b,P,_,M,E,v,C){if(b>0)p(d.c,d.a,d.b,T,y,m,E,_,M,v,C);else if(P>0)p(d.b,d.a,d.c,m,y,T,M,_,E,v,C);else if(M*E>0||_!=0)p(d.a,d.b,d.c,y,m,T,_,M,E,v,C);else if(M!=0)p(d.b,d.a,d.c,m,y,T,M,_,E,v,C);else if(E!=0)p(d.c,d.a,d.b,T,y,m,E,_,M,v,C);else return!0;return!1}function A(d,y,m,T){const b=y.degenerateSegment,P=d.plane.distanceToPoint(b.start),_=d.plane.distanceToPoint(b.end);return K(P)?K(_)?u(d,y,m,T):(m&&(m.start.copy(b.start),m.end.copy(b.start)),d.containsPoint(b.start)):K(_)?(m&&(m.start.copy(b.end),m.end.copy(b.end)),d.containsPoint(b.end)):d.plane.intersectLine(b,n)!=null?(m&&(m.start.copy(n),m.end.copy(n)),d.containsPoint(n)):!1}function w(d,y,m){const T=y.a;return K(d.plane.distanceToPoint(T))&&d.containsPoint(T)?(m&&(m.start.copy(T),m.end.copy(T)),!0):!1}function x(d,y,m){const T=d.degenerateSegment,b=y.a;return T.closestPointToPoint(b,!0,n),b.distanceToSquared(n)<os?(m&&(m.start.copy(b),m.end.copy(b)),!0):!1}function g(d,y,m,T){if(d.isDegenerateIntoSegment)if(y.isDegenerateIntoSegment){const b=d.degenerateSegment,P=y.degenerateSegment,_=s,M=r;b.delta(_),P.delta(M);const E=n.subVectors(P.start,b.start),v=_.x*M.y-_.y*M.x;if(K(v))return!1;const C=(E.x*M.y-E.y*M.x)/v,B=-(_.x*E.y-_.y*E.x)/v;if(C<0||C>1||B<0||B>1)return!1;const z=b.start.z+_.z*C,k=P.start.z+M.z*B;return K(z-k)?(m&&(m.start.copy(b.start).addScaledVector(_,C),m.end.copy(b.start).addScaledVector(_,C)),!0):!1}else return y.isDegenerateIntoPoint?x(d,y,m):A(y,d,m,T);else{if(d.isDegenerateIntoPoint)return y.isDegenerateIntoPoint?y.a.distanceToSquared(d.a)<os?(m&&(m.start.copy(d.a),m.end.copy(d.a)),!0):!1:y.isDegenerateIntoSegment?x(y,d,m):w(y,d,m);if(y.isDegenerateIntoPoint)return w(d,y,m);if(y.isDegenerateIntoSegment)return A(d,y,m,T)}}return function(y,m=null,T=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(o.copy(y),o.update(),y=o);const b=g(this,y,m,T);if(b!==void 0)return b;const P=this.plane,_=y.plane;let M=_.distanceToPoint(this.a),E=_.distanceToPoint(this.b),v=_.distanceToPoint(this.c);K(M)&&(M=0),K(E)&&(E=0),K(v)&&(v=0);const C=M*E,B=M*v;if(C>0&&B>0)return!1;let z=P.distanceToPoint(y.a),k=P.distanceToPoint(y.b),F=P.distanceToPoint(y.c);K(z)&&(z=0),K(k)&&(k=0),K(F)&&(F=0);const $=z*k,R=z*F;if($>0&&R>0)return!1;s.copy(P.normal),r.copy(_.normal);const bt=s.cross(r);let St=0,At=Math.abs(bt.x);const ye=Math.abs(bt.y);ye>At&&(At=ye,St=1),Math.abs(bt.z)>At&&(St=2);const Vt=Yi[St],Js=this.a[Vt],ti=this.b[Vt],ei=this.c[Vt],ni=y.a[Vt],si=y.b[Vt],ii=y.c[Vt];if(S(this,Js,ti,ei,C,B,M,E,v,l,c))return u(this,y,m,T);if(S(y,ni,si,ii,$,R,z,k,F,h,a))return u(this,y,m,T);if(l.y<l.x){const tn=l.y;l.y=l.x,l.x=tn,f.copy(c.start),c.start.copy(c.end),c.end.copy(f)}if(h.y<h.x){const tn=h.y;h.y=h.x,h.x=tn,f.copy(a.start),a.start.copy(a.end),a.end.copy(f)}return l.y<h.x||h.y<l.x?!1:(m&&(h.x>l.x?m.start.copy(a.start):m.start.copy(c.start),h.y<l.y?m.end.copy(a.end):m.end.copy(c.end)),!0)}}();rt.prototype.distanceToPoint=function(){const o=new I;return function(e){return this.closestPointToPoint(e,o),e.distanceTo(o)}}();rt.prototype.distanceToTriangle=function(){const o=new I,t=new I,e=["a","b","c"],n=new ot,s=new ot;return function(i,c=null,a=null){const f=c||a?n:null;if(this.intersectsTriangle(i,f))return(c||a)&&(c&&f.getCenter(c),a&&f.getCenter(a)),0;let l=1/0;for(let h=0;h<3;h++){let u;const p=e[h],S=i[p];this.closestPointToPoint(S,o),u=S.distanceToSquared(o),u<l&&(l=u,c&&c.copy(o),a&&a.copy(S));const A=this[p];i.closestPointToPoint(A,o),u=A.distanceToSquared(o),u<l&&(l=u,c&&c.copy(A),a&&a.copy(o))}for(let h=0;h<3;h++){const u=e[h],p=e[(h+1)%3];n.set(this[u],this[p]);for(let S=0;S<3;S++){const A=e[S],w=e[(S+1)%3];s.set(i[A],i[w]),Nn(n,s,o,t);const x=o.distanceToSquared(t);x<l&&(l=x,c&&c.copy(o),a&&a.copy(t))}}return Math.sqrt(l)}}();class Y{constructor(t,e,n){this.isOrientedBox=!0,this.min=new I,this.max=new I,this.matrix=new it,this.invMatrix=new it,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new wt),this.alignedSatBounds=new Array(3).fill().map(()=>new wt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Y.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let h=0;h<=1;h++){const u=1*f|2*l|4*h,p=s[u];p.x=f?n.x:e.x,p.y=l?n.y:e.y,p.z=h?n.z:e.z,p.applyMatrix4(t)}const r=this.satBounds,i=this.satAxes,c=s[0];for(let f=0;f<3;f++){const l=i[f],h=r[f],u=1<<f,p=s[u];l.subVectors(c,p),h.setFromPoints(l,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Y.prototype.intersectsBox=function(){const o=new wt;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,r=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(o.min=n.x,o.max=s.x,c[0].isSeparated(o)||(o.min=n.y,o.max=s.y,c[1].isSeparated(o))||(o.min=n.z,o.max=s.z,c[2].isSeparated(o)))return!1;for(let a=0;a<3;a++){const f=i[a],l=r[a];if(o.setFromBox(f,e),l.isSeparated(o))return!1}return!0}}();Y.prototype.intersectsTriangle=function(){const o=new rt,t=new Array(3),e=new wt,n=new wt,s=new I;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(o.copy(i),o.update(),i=o);const c=this.satBounds,a=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let u=0;u<3;u++){const p=c[u],S=a[u];if(e.setFromPoints(S,t),p.isSeparated(e))return!1}const f=i.satBounds,l=i.satAxes,h=this.points;for(let u=0;u<3;u++){const p=f[u],S=l[u];if(e.setFromPoints(S,h),p.isSeparated(e))return!1}for(let u=0;u<3;u++){const p=a[u];for(let S=0;S<4;S++){const A=l[S];if(s.crossVectors(p,A),e.setFromPoints(s,t),n.setFromPoints(s,h),e.isSeparated(n))return!1}}return!0}}();Y.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();Y.prototype.distanceToPoint=function(){const o=new I;return function(e){return this.closestPointToPoint(e,o),e.distanceTo(o)}}();Y.prototype.distanceToBox=function(){const o=["x","y","z"],t=new Array(12).fill().map(()=>new ot),e=new Array(12).fill().map(()=>new ot),n=new I,s=new I;return function(i,c=0,a=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||f)&&(i.getCenter(s),this.closestPointToPoint(s,n),i.closestPointToPoint(n,s),a&&a.copy(n),f&&f.copy(s)),0;const l=c*c,h=i.min,u=i.max,p=this.points;let S=1/0;for(let w=0;w<8;w++){const x=p[w];s.copy(x).clamp(h,u);const g=x.distanceToSquared(s);if(g<S&&(S=g,a&&a.copy(x),f&&f.copy(s),g<l))return Math.sqrt(g)}let A=0;for(let w=0;w<3;w++)for(let x=0;x<=1;x++)for(let g=0;g<=1;g++){const d=(w+1)%3,y=(w+2)%3,m=x<<d|g<<y,T=1<<w|x<<d|g<<y,b=p[m],P=p[T];t[A].set(b,P);const M=o[w],E=o[d],v=o[y],C=e[A],B=C.start,z=C.end;B[M]=h[M],B[E]=x?h[E]:u[E],B[v]=g?h[v]:u[E],z[M]=u[M],z[E]=x?h[E]:u[E],z[v]=g?h[v]:u[E],A++}for(let w=0;w<=1;w++)for(let x=0;x<=1;x++)for(let g=0;g<=1;g++){s.x=w?u.x:h.x,s.y=x?u.y:h.y,s.z=g?u.z:h.z,this.closestPointToPoint(s,n);const d=s.distanceToSquared(n);if(d<S&&(S=d,a&&a.copy(n),f&&f.copy(s),d<l))return Math.sqrt(d)}for(let w=0;w<12;w++){const x=t[w];for(let g=0;g<12;g++){const d=e[g];Nn(x,d,n,s);const y=n.distanceToSquared(s);if(y<S&&(S=y,a&&a.copy(n),f&&f.copy(s),y<l))return Math.sqrt(y)}}return Math.sqrt(S)}}();class Un{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Qi extends Un{constructor(){super(()=>new rt)}}const st=new Qi;class Zi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const N=new Zi;let Et,Jt;const jt=[],Te=new Un(()=>new pt);function Wi(o,t,e,n,s,r){Et=Te.getPrimitive(),Jt=Te.getPrimitive(),jt.push(Et,Jt),N.setBuffer(o._roots[t]);const i=In(0,o.geometry,e,n,s,r);N.clearBuffer(),Te.releasePrimitive(Et),Te.releasePrimitive(Jt),jt.pop(),jt.pop();const c=jt.length;return c>0&&(Jt=jt[c-1],Et=jt[c-2]),i}function In(o,t,e,n,s=null,r=0,i=0){const{float32Array:c,uint16Array:a,uint32Array:f}=N;let l=o*2;if(Z(l,a)){const u=W(o,f),p=tt(l,a);return H(o,c,Et),n(u,p,!1,i,r+o,Et)}else{let M=function(v){const{uint16Array:C,uint32Array:B}=N;let z=v*2;for(;!Z(z,C);)v=et(v),z=v*2;return W(v,B)},E=function(v){const{uint16Array:C,uint32Array:B}=N;let z=v*2;for(;!Z(z,C);)v=nt(v,B),z=v*2;return W(v,B)+tt(z,C)};const u=et(o),p=nt(o,f);let S=u,A=p,w,x,g,d;if(s&&(g=Et,d=Jt,H(S,c,g),H(A,c,d),w=s(g),x=s(d),x<w)){S=p,A=u;const v=w;w=x,x=v,g=d}g||(g=Et,H(S,c,g));const y=Z(S*2,a),m=e(g,y,w,i+1,r+S);let T;if(m===ts){const v=M(S),B=E(S)-v;T=n(v,B,!0,i+1,r+S,g)}else T=m&&In(S,t,e,n,s,r,i+1);if(T)return!0;d=Jt,H(A,c,d);const b=Z(A*2,a),P=e(d,b,x,i+1,r+A);let _;if(P===ts){const v=M(A),B=E(A)-v;_=n(v,B,!0,i+1,r+A,d)}else _=P&&In(A,t,e,n,s,r,i+1);return!!_}}const se=new I,cn=new I;function Ki(o,t,e={},n=0,s=1/0){const r=n*n,i=s*s;let c=1/0,a=null;if(o.shapecast({boundsTraverseOrder:l=>(se.copy(t).clamp(l.min,l.max),se.distanceToSquared(t)),intersectsBounds:(l,h,u)=>u<c&&u<i,intersectsTriangle:(l,h)=>{l.closestPointToPoint(t,se);const u=t.distanceToSquared(se);return u<c&&(cn.copy(se),c=u,a=h),u<r}}),c===1/0)return null;const f=Math.sqrt(c);return e.point?e.point.copy(cn):e.point=cn.clone(),e.distance=f,e.faceIndex=a,e}const Pe=parseInt(Fs)>=169,Ji=parseInt(Fs)<=161,kt=new I,Ft=new I,Lt=new I,_e=new ht,ve=new ht,Ce=new ht,rs=new I,as=new I,cs=new I,ie=new I;function to(o,t,e,n,s,r,i,c){let a;if(r===ci?a=o.intersectTriangle(n,e,t,!0,s):a=o.intersectTriangle(t,e,n,r!==Qe,s),a===null)return null;const f=o.origin.distanceTo(s);return f<i||f>c?null:{distance:f,point:s.clone()}}function eo(o,t,e,n,s,r,i,c,a,f,l){kt.fromBufferAttribute(t,r),Ft.fromBufferAttribute(t,i),Lt.fromBufferAttribute(t,c);const h=to(o,kt,Ft,Lt,ie,a,f,l);if(h){if(n){_e.fromBufferAttribute(n,r),ve.fromBufferAttribute(n,i),Ce.fromBufferAttribute(n,c),h.uv=new ht;const p=Q.getInterpolation(ie,kt,Ft,Lt,_e,ve,Ce,h.uv);Pe||(h.uv=p)}if(s){_e.fromBufferAttribute(s,r),ve.fromBufferAttribute(s,i),Ce.fromBufferAttribute(s,c),h.uv1=new ht;const p=Q.getInterpolation(ie,kt,Ft,Lt,_e,ve,Ce,h.uv1);Pe||(h.uv1=p),Ji&&(h.uv2=h.uv1)}if(e){rs.fromBufferAttribute(e,r),as.fromBufferAttribute(e,i),cs.fromBufferAttribute(e,c),h.normal=new I;const p=Q.getInterpolation(ie,kt,Ft,Lt,rs,as,cs,h.normal);h.normal.dot(o.direction)>0&&h.normal.multiplyScalar(-1),Pe||(h.normal=p)}const u={a:r,b:i,c,normal:new I,materialIndex:0};if(Q.getNormal(kt,Ft,Lt,u.normal),h.face=u,h.faceIndex=r,Pe){const p=new I;Q.getBarycoord(ie,kt,Ft,Lt,p),h.barycoord=p}}return h}function Ke(o,t,e,n,s,r,i){const c=n*3;let a=c+0,f=c+1,l=c+2;const h=o.index;o.index&&(a=h.getX(a),f=h.getX(f),l=h.getX(l));const{position:u,normal:p,uv:S,uv1:A}=o.attributes,w=eo(e,u,p,S,A,a,f,l,t,r,i);return w?(w.faceIndex=n,s&&s.push(w),w):null}function X(o,t,e,n){const s=o.a,r=o.b,i=o.c;let c=t,a=t+1,f=t+2;e&&(c=e.getX(c),a=e.getX(a),f=e.getX(f)),s.x=n.getX(c),s.y=n.getY(c),s.z=n.getZ(c),r.x=n.getX(a),r.y=n.getY(a),r.z=n.getZ(a),i.x=n.getX(f),i.y=n.getY(f),i.z=n.getZ(f)}function no(o,t,e,n,s,r,i,c){const{geometry:a,_indirectBuffer:f}=o;for(let l=n,h=n+s;l<h;l++)Ke(a,t,e,l,r,i,c)}function so(o,t,e,n,s,r,i){const{geometry:c,_indirectBuffer:a}=o;let f=1/0,l=null;for(let h=n,u=n+s;h<u;h++){let p;p=Ke(c,t,e,h,null,r,i),p&&p.distance<f&&(l=p,f=p.distance)}return l}function io(o,t,e,n,s,r,i){const{geometry:c}=e,{index:a}=c,f=c.attributes.position;for(let l=o,h=t+o;l<h;l++){let u;if(u=l,X(i,u*3,a,f),i.needsUpdate=!0,n(i,u,s,r))return!0}return!1}function oo(o,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=o.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,i,c,a,f=0;const l=o._roots;for(let u=0,p=l.length;u<p;u++)r=l[u],i=new Uint32Array(r),c=new Uint16Array(r),a=new Float32Array(r),h(0,f),f+=r.byteLength;function h(u,p,S=!1){const A=u*2;if(c[A+15]===We){const x=i[u+6],g=c[A+14];let d=1/0,y=1/0,m=1/0,T=-1/0,b=-1/0,P=-1/0;for(let _=3*x,M=3*(x+g);_<M;_++){let E=n[_];const v=s.getX(E),C=s.getY(E),B=s.getZ(E);v<d&&(d=v),v>T&&(T=v),C<y&&(y=C),C>b&&(b=C),B<m&&(m=B),B>P&&(P=B)}return a[u+0]!==d||a[u+1]!==y||a[u+2]!==m||a[u+3]!==T||a[u+4]!==b||a[u+5]!==P?(a[u+0]=d,a[u+1]=y,a[u+2]=m,a[u+3]=T,a[u+4]=b,a[u+5]=P,!0):!1}else{const x=u+8,g=i[u+6],d=x+p,y=g+p;let m=S,T=!1,b=!1;t?m||(T=t.has(d),b=t.has(y),m=!T&&!b):(T=!0,b=!0);const P=m||T,_=m||b;let M=!1;P&&(M=h(x,p,m));let E=!1;_&&(E=h(g,p,m));const v=M||E;if(v)for(let C=0;C<3;C++){const B=x+C,z=g+C,k=a[B],F=a[B+3],$=a[z],R=a[z+3];a[u+C]=k<$?k:$,a[u+C+3]=F>R?F:R}return v}}}function Bt(o,t,e,n,s){let r,i,c,a,f,l;const h=1/e.direction.x,u=1/e.direction.y,p=1/e.direction.z,S=e.origin.x,A=e.origin.y,w=e.origin.z;let x=t[o],g=t[o+3],d=t[o+1],y=t[o+3+1],m=t[o+2],T=t[o+3+2];return h>=0?(r=(x-S)*h,i=(g-S)*h):(r=(g-S)*h,i=(x-S)*h),u>=0?(c=(d-A)*u,a=(y-A)*u):(c=(y-A)*u,a=(d-A)*u),r>a||c>i||((c>r||isNaN(r))&&(r=c),(a<i||isNaN(i))&&(i=a),p>=0?(f=(m-w)*p,l=(T-w)*p):(f=(T-w)*p,l=(m-w)*p),r>l||f>i)?!1:((f>r||r!==r)&&(r=f),(l<i||i!==i)&&(i=l),r<=s&&i>=n)}function ro(o,t,e,n,s,r,i,c){const{geometry:a,_indirectBuffer:f}=o;for(let l=n,h=n+s;l<h;l++){let u=f?f[l]:l;Ke(a,t,e,u,r,i,c)}}function ao(o,t,e,n,s,r,i){const{geometry:c,_indirectBuffer:a}=o;let f=1/0,l=null;for(let h=n,u=n+s;h<u;h++){let p;p=Ke(c,t,e,a?a[h]:h,null,r,i),p&&p.distance<f&&(l=p,f=p.distance)}return l}function co(o,t,e,n,s,r,i){const{geometry:c}=e,{index:a}=c,f=c.attributes.position;for(let l=o,h=t+o;l<h;l++){let u;if(u=e.resolveTriangleIndex(l),X(i,u*3,a,f),i.needsUpdate=!0,n(i,u,s,r))return!0}return!1}function lo(o,t,e,n,s,r,i){N.setBuffer(o._roots[t]),Bn(0,o,e,n,s,r,i),N.clearBuffer()}function Bn(o,t,e,n,s,r,i){const{float32Array:c,uint16Array:a,uint32Array:f}=N,l=o*2;if(Z(l,a)){const u=W(o,f),p=tt(l,a);no(t,e,n,u,p,s,r,i)}else{const u=et(o);Bt(u,c,n,r,i)&&Bn(u,t,e,n,s,r,i);const p=nt(o,f);Bt(p,c,n,r,i)&&Bn(p,t,e,n,s,r,i)}}const uo=["x","y","z"];function fo(o,t,e,n,s,r){N.setBuffer(o._roots[t]);const i=zn(0,o,e,n,s,r);return N.clearBuffer(),i}function zn(o,t,e,n,s,r){const{float32Array:i,uint16Array:c,uint32Array:a}=N;let f=o*2;if(Z(f,c)){const h=W(o,a),u=tt(f,c);return so(t,e,n,h,u,s,r)}else{const h=Hs(o,a),u=uo[h],S=n.direction[u]>=0;let A,w;S?(A=et(o),w=nt(o,a)):(A=nt(o,a),w=et(o));const g=Bt(A,i,n,s,r)?zn(A,t,e,n,s,r):null;if(g){const m=g.point[u];if(S?m<=i[w+h]:m>=i[w+h+3])return g}const y=Bt(w,i,n,s,r)?zn(w,t,e,n,s,r):null;return g&&y?g.distance<=y.distance?g:y:g||y||null}}const Me=new pt,Gt=new rt,qt=new rt,oe=new it,ls=new Y,Ee=new Y;function ho(o,t,e,n){N.setBuffer(o._roots[t]);const s=Dn(0,o,e,n);return N.clearBuffer(),s}function Dn(o,t,e,n,s=null){const{float32Array:r,uint16Array:i,uint32Array:c}=N;let a=o*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),ls.set(e.boundingBox.min,e.boundingBox.max,n),s=ls),Z(a,i)){const l=t.geometry,h=l.index,u=l.attributes.position,p=e.index,S=e.attributes.position,A=W(o,c),w=tt(a,i);if(oe.copy(n).invert(),e.boundsTree)return H(o,r,Ee),Ee.matrix.copy(oe),Ee.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>Ee.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let d=A*3,y=(w+A)*3;d<y;d+=3)if(X(qt,d,h,u),qt.needsUpdate=!0,g.intersectsTriangle(qt))return!0;return!1}});{const x=zt(e);for(let g=A*3,d=(w+A)*3;g<d;g+=3){X(Gt,g,h,u),Gt.a.applyMatrix4(oe),Gt.b.applyMatrix4(oe),Gt.c.applyMatrix4(oe),Gt.needsUpdate=!0;for(let y=0,m=x*3;y<m;y+=3)if(X(qt,y,p,S),qt.needsUpdate=!0,Gt.intersectsTriangle(qt))return!0}}}else{const l=o+8,h=c[o+6];return H(l,r,Me),!!(s.intersectsBox(Me)&&Dn(l,t,e,n,s)||(H(h,r,Me),s.intersectsBox(Me)&&Dn(h,t,e,n,s)))}}const Ie=new it,ln=new Y,re=new Y,po=new I,mo=new I,yo=new I,go=new I;function xo(o,t,e,n={},s={},r=0,i=1/0){t.boundingBox||t.computeBoundingBox(),ln.set(t.boundingBox.min,t.boundingBox.max,e),ln.needsUpdate=!0;const c=o.geometry,a=c.attributes.position,f=c.index,l=t.attributes.position,h=t.index,u=st.getPrimitive(),p=st.getPrimitive();let S=po,A=mo,w=null,x=null;s&&(w=yo,x=go);let g=1/0,d=null,y=null;return Ie.copy(e).invert(),re.matrix.copy(Ie),o.shapecast({boundsTraverseOrder:m=>ln.distanceToBox(m),intersectsBounds:(m,T,b)=>b<g&&b<i?(T&&(re.min.copy(m.min),re.max.copy(m.max),re.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>re.distanceToBox(P),intersectsBounds:(P,_,M)=>M<g&&M<i,intersectsRange:(P,_)=>{for(let M=P,E=P+_;M<E;M++){X(p,3*M,h,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let v=m,C=m+T;v<C;v++){X(u,3*v,f,a),u.needsUpdate=!0;const B=u.distanceToTriangle(p,S,w);if(B<g&&(A.copy(S),x&&x.copy(w),g=B,d=v,y=M),B<r)return!0}}}});{const b=zt(t);for(let P=0,_=b;P<_;P++){X(p,3*P,h,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let M=m,E=m+T;M<E;M++){X(u,3*M,f,a),u.needsUpdate=!0;const v=u.distanceToTriangle(p,S,w);if(v<g&&(A.copy(S),x&&x.copy(w),g=v,d=M,y=P),v<r)return!0}}}}}),st.releasePrimitive(u),st.releasePrimitive(p),g===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=g,n.faceIndex=d,s&&(s.point?s.point.copy(x):s.point=x.clone(),s.point.applyMatrix4(Ie),A.applyMatrix4(Ie),s.distance=A.sub(s.point).length(),s.faceIndex=y),n)}function wo(o,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=o.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,i,c,a,f=0;const l=o._roots;for(let u=0,p=l.length;u<p;u++)r=l[u],i=new Uint32Array(r),c=new Uint16Array(r),a=new Float32Array(r),h(0,f),f+=r.byteLength;function h(u,p,S=!1){const A=u*2;if(c[A+15]===We){const x=i[u+6],g=c[A+14];let d=1/0,y=1/0,m=1/0,T=-1/0,b=-1/0,P=-1/0;for(let _=x,M=x+g;_<M;_++){const E=3*o.resolveTriangleIndex(_);for(let v=0;v<3;v++){let C=E+v;C=n?n[C]:C;const B=s.getX(C),z=s.getY(C),k=s.getZ(C);B<d&&(d=B),B>T&&(T=B),z<y&&(y=z),z>b&&(b=z),k<m&&(m=k),k>P&&(P=k)}}return a[u+0]!==d||a[u+1]!==y||a[u+2]!==m||a[u+3]!==T||a[u+4]!==b||a[u+5]!==P?(a[u+0]=d,a[u+1]=y,a[u+2]=m,a[u+3]=T,a[u+4]=b,a[u+5]=P,!0):!1}else{const x=u+8,g=i[u+6],d=x+p,y=g+p;let m=S,T=!1,b=!1;t?m||(T=t.has(d),b=t.has(y),m=!T&&!b):(T=!0,b=!0);const P=m||T,_=m||b;let M=!1;P&&(M=h(x,p,m));let E=!1;_&&(E=h(g,p,m));const v=M||E;if(v)for(let C=0;C<3;C++){const B=x+C,z=g+C,k=a[B],F=a[B+3],$=a[z],R=a[z+3];a[u+C]=k<$?k:$,a[u+C+3]=F>R?F:R}return v}}}function bo(o,t,e,n,s,r,i){N.setBuffer(o._roots[t]),kn(0,o,e,n,s,r,i),N.clearBuffer()}function kn(o,t,e,n,s,r,i){const{float32Array:c,uint16Array:a,uint32Array:f}=N,l=o*2;if(Z(l,a)){const u=W(o,f),p=tt(l,a);ro(t,e,n,u,p,s,r,i)}else{const u=et(o);Bt(u,c,n,r,i)&&kn(u,t,e,n,s,r,i);const p=nt(o,f);Bt(p,c,n,r,i)&&kn(p,t,e,n,s,r,i)}}const So=["x","y","z"];function Ao(o,t,e,n,s,r){N.setBuffer(o._roots[t]);const i=Fn(0,o,e,n,s,r);return N.clearBuffer(),i}function Fn(o,t,e,n,s,r){const{float32Array:i,uint16Array:c,uint32Array:a}=N;let f=o*2;if(Z(f,c)){const h=W(o,a),u=tt(f,c);return ao(t,e,n,h,u,s,r)}else{const h=Hs(o,a),u=So[h],S=n.direction[u]>=0;let A,w;S?(A=et(o),w=nt(o,a)):(A=nt(o,a),w=et(o));const g=Bt(A,i,n,s,r)?Fn(A,t,e,n,s,r):null;if(g){const m=g.point[u];if(S?m<=i[w+h]:m>=i[w+h+3])return g}const y=Bt(w,i,n,s,r)?Fn(w,t,e,n,s,r):null;return g&&y?g.distance<=y.distance?g:y:g||y||null}}const Be=new pt,Yt=new rt,Qt=new rt,ae=new it,us=new Y,ze=new Y;function To(o,t,e,n){N.setBuffer(o._roots[t]);const s=Ln(0,o,e,n);return N.clearBuffer(),s}function Ln(o,t,e,n,s=null){const{float32Array:r,uint16Array:i,uint32Array:c}=N;let a=o*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),us.set(e.boundingBox.min,e.boundingBox.max,n),s=us),Z(a,i)){const l=t.geometry,h=l.index,u=l.attributes.position,p=e.index,S=e.attributes.position,A=W(o,c),w=tt(a,i);if(ae.copy(n).invert(),e.boundsTree)return H(o,r,ze),ze.matrix.copy(ae),ze.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>ze.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let d=A,y=w+A;d<y;d++)if(X(Qt,3*t.resolveTriangleIndex(d),h,u),Qt.needsUpdate=!0,g.intersectsTriangle(Qt))return!0;return!1}});{const x=zt(e);for(let g=A,d=w+A;g<d;g++){const y=t.resolveTriangleIndex(g);X(Yt,3*y,h,u),Yt.a.applyMatrix4(ae),Yt.b.applyMatrix4(ae),Yt.c.applyMatrix4(ae),Yt.needsUpdate=!0;for(let m=0,T=x*3;m<T;m+=3)if(X(Qt,m,p,S),Qt.needsUpdate=!0,Yt.intersectsTriangle(Qt))return!0}}}else{const l=o+8,h=c[o+6];return H(l,r,Be),!!(s.intersectsBox(Be)&&Ln(l,t,e,n,s)||(H(h,r,Be),s.intersectsBox(Be)&&Ln(h,t,e,n,s)))}}const De=new it,un=new Y,ce=new Y,Po=new I,_o=new I,vo=new I,Co=new I;function Mo(o,t,e,n={},s={},r=0,i=1/0){t.boundingBox||t.computeBoundingBox(),un.set(t.boundingBox.min,t.boundingBox.max,e),un.needsUpdate=!0;const c=o.geometry,a=c.attributes.position,f=c.index,l=t.attributes.position,h=t.index,u=st.getPrimitive(),p=st.getPrimitive();let S=Po,A=_o,w=null,x=null;s&&(w=vo,x=Co);let g=1/0,d=null,y=null;return De.copy(e).invert(),ce.matrix.copy(De),o.shapecast({boundsTraverseOrder:m=>un.distanceToBox(m),intersectsBounds:(m,T,b)=>b<g&&b<i?(T&&(ce.min.copy(m.min),ce.max.copy(m.max),ce.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:P=>ce.distanceToBox(P),intersectsBounds:(P,_,M)=>M<g&&M<i,intersectsRange:(P,_)=>{for(let M=P,E=P+_;M<E;M++){const v=b.resolveTriangleIndex(M);X(p,3*v,h,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let C=m,B=m+T;C<B;C++){const z=o.resolveTriangleIndex(C);X(u,3*z,f,a),u.needsUpdate=!0;const k=u.distanceToTriangle(p,S,w);if(k<g&&(A.copy(S),x&&x.copy(w),g=k,d=C,y=M),k<r)return!0}}}})}else{const b=zt(t);for(let P=0,_=b;P<_;P++){X(p,3*P,h,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let M=m,E=m+T;M<E;M++){const v=o.resolveTriangleIndex(M);X(u,3*v,f,a),u.needsUpdate=!0;const C=u.distanceToTriangle(p,S,w);if(C<g&&(A.copy(S),x&&x.copy(w),g=C,d=M,y=P),C<r)return!0}}}}}),st.releasePrimitive(u),st.releasePrimitive(p),g===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=g,n.faceIndex=d,s&&(s.point?s.point.copy(x):s.point=x.clone(),s.point.applyMatrix4(De),A.applyMatrix4(De),s.distance=A.sub(s.point).length(),s.faceIndex=y),n)}function Eo(){return typeof SharedArrayBuffer<"u"}const de=new N.constructor,Ge=new N.constructor,Ct=new Un(()=>new pt),Zt=new pt,Wt=new pt,fn=new pt,hn=new pt;let pn=!1;function Io(o,t,e,n){if(pn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pn=!0;const s=o._roots,r=t._roots;let i,c=0,a=0;const f=new it().copy(e).invert();for(let l=0,h=s.length;l<h;l++){de.setBuffer(s[l]),a=0;const u=Ct.getPrimitive();H(0,de.float32Array,u),u.applyMatrix4(f);for(let p=0,S=r.length;p<S&&(Ge.setBuffer(r[p]),i=at(0,0,e,f,n,c,a,0,0,u),Ge.clearBuffer(),a+=r[p].length,!i);p++);if(Ct.releasePrimitive(u),de.clearBuffer(),c+=s[l].length,i)break}return pn=!1,i}function at(o,t,e,n,s,r=0,i=0,c=0,a=0,f=null,l=!1){let h,u;l?(h=Ge,u=de):(h=de,u=Ge);const p=h.float32Array,S=h.uint32Array,A=h.uint16Array,w=u.float32Array,x=u.uint32Array,g=u.uint16Array,d=o*2,y=t*2,m=Z(d,A),T=Z(y,g);let b=!1;if(T&&m)l?b=s(W(t,x),tt(t*2,g),W(o,S),tt(o*2,A),a,i+t,c,r+o):b=s(W(o,S),tt(o*2,A),W(t,x),tt(t*2,g),c,r+o,a,i+t);else if(T){const P=Ct.getPrimitive();H(t,w,P),P.applyMatrix4(e);const _=et(o),M=nt(o,S);H(_,p,Zt),H(M,p,Wt);const E=P.intersectsBox(Zt),v=P.intersectsBox(Wt);b=E&&at(t,_,n,e,s,i,r,a,c+1,P,!l)||v&&at(t,M,n,e,s,i,r,a,c+1,P,!l),Ct.releasePrimitive(P)}else{const P=et(t),_=nt(t,x);H(P,w,fn),H(_,w,hn);const M=f.intersectsBox(fn),E=f.intersectsBox(hn);if(M&&E)b=at(o,P,e,n,s,r,i,c,a+1,f,l)||at(o,_,e,n,s,r,i,c,a+1,f,l);else if(M)if(m)b=at(o,P,e,n,s,r,i,c,a+1,f,l);else{const v=Ct.getPrimitive();v.copy(fn).applyMatrix4(e);const C=et(o),B=nt(o,S);H(C,p,Zt),H(B,p,Wt);const z=v.intersectsBox(Zt),k=v.intersectsBox(Wt);b=z&&at(P,C,n,e,s,i,r,a,c+1,v,!l)||k&&at(P,B,n,e,s,i,r,a,c+1,v,!l),Ct.releasePrimitive(v)}else if(E)if(m)b=at(o,_,e,n,s,r,i,c,a+1,f,l);else{const v=Ct.getPrimitive();v.copy(hn).applyMatrix4(e);const C=et(o),B=nt(o,S);H(C,p,Zt),H(B,p,Wt);const z=v.intersectsBox(Zt),k=v.intersectsBox(Wt);b=z&&at(_,C,n,e,s,i,r,a,c+1,v,!l)||k&&at(_,B,n,e,s,i,r,a,c+1,v,!l),Ct.releasePrimitive(v)}}return b}const ke=new Y,fs=new pt,Bo={strategy:Rs,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Hn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,r=t._indirectBuffer,i=n.getIndex();let c;return e.cloneBuffers?c={roots:s.map(a=>a.slice()),index:i?i.array.slice():null,indirectBuffer:r?r.slice():null}:c={roots:s,index:i?i.array:null,indirectBuffer:r},c}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:s,roots:r,indirectBuffer:i}=t,c=new Hn(e,{...n,[on]:!0});if(c._roots=r,c._indirectBuffer=i||null,n.setIndex){const a=e.getIndex();if(a===null){const f=new Ze(t.index,1,!1);e.setIndex(f)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Bo,[on]:!1},e),e.useSharedArrayBuffer&&!Eo())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[on]||(ji(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new pt))),this.resolveTriangleIndex=e.indirect?n=>this._indirectBuffer[n]:n=>n}refit(t=null){return(this.indirect?wo:oo)(this,t)}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),r=new Uint16Array(n);i(0);function i(c,a=0){const f=c*2,l=r[f+15]===We;if(l){const h=s[c+6],u=r[f+14];t(a,l,new Float32Array(n,c*4,6),h,u)}else{const h=c+pe/4,u=s[c+6],p=s[c+7];t(a,l,new Float32Array(n,c*4,6),p)||(i(h,a+1),i(u,a+1))}}}raycast(t,e=jn,n=0,s=1/0){const r=this._roots,i=this.geometry,c=[],a=e.isMaterial,f=Array.isArray(e),l=i.groups,h=a?e.side:e,u=this.indirect?bo:lo;for(let p=0,S=r.length;p<S;p++){const A=f?e[l[p].materialIndex].side:h,w=c.length;if(u(this,p,A,t,c,n,s),f){const x=l[p].materialIndex;for(let g=w,d=c.length;g<d;g++)c[g].face.materialIndex=x}}return c}raycastFirst(t,e=jn,n=0,s=1/0){const r=this._roots,i=this.geometry,c=e.isMaterial,a=Array.isArray(e);let f=null;const l=i.groups,h=c?e.side:e,u=this.indirect?Ao:fo;for(let p=0,S=r.length;p<S;p++){const A=a?e[l[p].materialIndex].side:h,w=u(this,p,A,t,n,s);w!=null&&(f==null||w.distance<f.distance)&&(f=w,a&&(w.face.materialIndex=l[p].materialIndex))}return f}intersectsGeometry(t,e){let n=!1;const s=this._roots,r=this.indirect?To:ho;for(let i=0,c=s.length;i<c&&(n=r(this,i,t,e),!n);i++);return n}shapecast(t){const e=st.getPrimitive(),n=this.indirect?co:io;let{boundsTraverseOrder:s,intersectsBounds:r,intersectsRange:i,intersectsTriangle:c}=t;if(i&&c){const h=i;i=(u,p,S,A,w)=>h(u,p,S,A,w)?!0:n(u,p,this,c,S,A,e)}else i||(c?i=(h,u,p,S)=>n(h,u,this,c,p,S,e):i=(h,u,p)=>p);let a=!1,f=0;const l=this._roots;for(let h=0,u=l.length;h<u;h++){const p=l[h];if(a=Wi(this,h,r,i,s,f),a)break;f+=p.byteLength}return st.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:r}=n;const i=st.getPrimitive(),c=this.geometry.index,a=this.geometry.attributes.position,f=this.indirect?S=>{const A=this.resolveTriangleIndex(S);X(i,A*3,c,a)}:S=>{X(i,S*3,c,a)},l=st.getPrimitive(),h=t.geometry.index,u=t.geometry.attributes.position,p=t.indirect?S=>{const A=t.resolveTriangleIndex(S);X(l,A*3,h,u)}:S=>{X(l,S*3,h,u)};if(r){const S=(A,w,x,g,d,y,m,T)=>{for(let b=x,P=x+g;b<P;b++){p(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let _=A,M=A+w;_<M;_++)if(f(_),i.needsUpdate=!0,r(i,l,_,b,d,y,m,T))return!0}return!1};if(s){const A=s;s=function(w,x,g,d,y,m,T,b){return A(w,x,g,d,y,m,T,b)?!0:S(w,x,g,d,y,m,T,b)}}else s=S}return Io(this,t,e,s)}intersectsBox(t,e){return ke.set(t.min,t.max,e),ke.needsUpdate=!0,this.shapecast({intersectsBounds:n=>ke.intersectsBox(n),intersectsTriangle:n=>ke.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},r=0,i=1/0){return(this.indirect?Mo:xo)(this,t,e,n,s,r,i)}closestPointToPoint(t,e={},n=0,s=1/0){return Ki(this,t,e,n,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{H(0,new Float32Array(n),fs),t.union(fs)}),t}}const $s=1e-6,zo=$s*.5,Vs=Math.pow(10,-Math.log10($s)),Do=zo*Vs;function ft(o){return~~(o*Vs+Do)}function ko(o){return`${ft(o.x)},${ft(o.y)}`}function hs(o){return`${ft(o.x)},${ft(o.y)},${ft(o.z)}`}function Fo(o){return`${ft(o.x)},${ft(o.y)},${ft(o.z)},${ft(o.w)}`}function Lo(o,t,e){e.direction.subVectors(t,o).normalize();const n=o.dot(e.direction);return e.origin.copy(o).addScaledVector(e.direction,-n),e}function js(){return typeof SharedArrayBuffer<"u"}function Ro(o){if(o.buffer instanceof SharedArrayBuffer)return o;const t=o.constructor,e=o.buffer,n=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(n).set(s,0),new t(n)}function No(o,t=ArrayBuffer){return o>65535?new Uint32Array(new t(4*o)):new Uint16Array(new t(2*o))}function Uo(o,t){if(!o.index){const e=o.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=No(e,n);o.setIndex(new Ze(s,1));for(let r=0;r<e;r++)s[r]=r}}function Ho(o){return o.index?o.index.count:o.attributes.position.count}function On(o){return Ho(o)/3}const Oo=1e-8,Xo=new I;function $o(o){return~~(o/3)}function Vo(o){return o%3}function ps(o,t){return o.start-t.start}function ds(o,t){return Xo.subVectors(t,o.origin).dot(o.direction)}function jo(o,t,e,n=Oo){o.sort(ps),t.sort(ps);for(let c=0;c<o.length;c++){const a=o[c];for(let f=0;f<t.length;f++){const l=t[f];if(!(l.start>a.end)){if(a.end<l.start||l.end<a.start)continue;if(a.start<=l.start&&a.end>=l.end)r(l.end,a.end)||o.splice(c+1,0,{start:l.end,end:a.end,index:a.index}),a.end=l.start,l.start=0,l.end=0;else if(a.start>=l.start&&a.end<=l.end)r(a.end,l.end)||t.splice(f+1,0,{start:a.end,end:l.end,index:l.index}),l.end=a.start,a.start=0,a.end=0;else if(a.start<=l.start&&a.end<=l.end){const h=a.end;a.end=l.start,l.start=h}else if(a.start>=l.start&&a.end>=l.end){const h=l.end;l.end=a.start,a.start=h}else throw new Error}if(e.has(a.index)||e.set(a.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(a.index).push(l.index),e.get(l.index).push(a.index),i(l)&&(t.splice(f,1),f--),i(a)){o.splice(c,1),c--;break}}}s(o),s(t);function s(c){for(let a=0;a<c.length;a++)i(c[a])&&(c.splice(a,1),a--)}function r(c,a){return Math.abs(a-c)<n}function i(c){return Math.abs(c.end-c.start)<n}}const ms=1e-5,ys=1e-4;class Go{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let s=1/0,r=null;for(let a=0,f=e.length;a<f;a++){const l=e[a];if(i(l,t)&&i(l,n))continue;const h=c(l,t),u=c(l,n),p=Math.min(h,u);p<s&&(s=p,r=l)}return r;function i(a,f){const l=a.origin.distanceTo(f.origin)>ms;return a.direction.angleTo(f.direction)>ys||l}function c(a,f){const l=a.origin.distanceTo(f.origin),h=a.direction.angleTo(f.direction);return l/ms+h/ys}}}const dn=new I,mn=new I,Fe=new Ls;function qo(o,t,e){const n=o.attributes,s=o.index,r=n.position,i=new Map,c=new Map,a=Array.from(t),f=new Go;for(let l=0,h=a.length;l<h;l++){const u=a[l],p=$o(u),S=Vo(u);let A=3*p+S,w=3*p+(S+1)%3;s&&(A=s.getX(A),w=s.getX(w)),dn.fromBufferAttribute(r,A),mn.fromBufferAttribute(r,w),Lo(dn,mn,Fe);let x,g=f.findClosestRay(Fe);g===null&&(g=Fe.clone(),f.addRay(g)),c.has(g)||c.set(g,{forward:[],reverse:[],ray:g}),x=c.get(g);let d=ds(g,dn),y=ds(g,mn);d>y&&([d,y]=[y,d]),Fe.direction.dot(g.direction)<0?x.reverse.push({start:d,end:y,index:u}):x.forward.push({start:d,end:y,index:u})}return c.forEach(({forward:l,reverse:h},u)=>{jo(l,h,i,e),l.length===0&&h.length===0&&c.delete(u)}),{disjointConnectivityMap:i,fragmentMap:c}}const Yo=new ht,yn=new I,Qo=new $t,gn=["","",""];class Zo{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:s,degenerateEpsilon:r}=this,i=e?d:g,c=new Map,{attributes:a}=t,f=e?Object.keys(a):null,l=t.index,h=a.position;let u=On(t);const p=u;let S=0;n&&(S=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let A=this.data;(!A||A.length<3*p)&&(A=new Int32Array(3*p)),A.fill(-1);let w=0,x=new Set;for(let y=S,m=u*3+S;y<m;y+=3){const T=y;for(let b=0;b<3;b++){let P=T+b;l&&(P=l.getX(P)),gn[b]=i(P)}for(let b=0;b<3;b++){const P=(b+1)%3,_=gn[b],M=gn[P],E=`${M}_${_}`;if(c.has(E)){const v=T+b,C=c.get(E);A[v]=C,A[C]=v,c.delete(E),w+=2,x.delete(C)}else{const v=`${_}_${M}`,C=T+b;c.set(v,C),x.add(C)}}}if(s){const{fragmentMap:y,disjointConnectivityMap:m}=qo(t,x,r);x.clear(),y.forEach(({forward:T,reverse:b})=>{T.forEach(({index:P})=>x.add(P)),b.forEach(({index:P})=>x.add(P))}),this.unmatchedDisjointEdges=y,this.disjointConnections=m,w=u*3-x.size}this.matchedEdges=w,this.unmatchedEdges=x.size,this.data=A;function g(y){return yn.fromBufferAttribute(h,y),hs(yn)}function d(y){let m="";for(let T=0,b=f.length;T<b;T++){const P=a[f[T]];let _;switch(P.itemSize){case 1:_=ft(P.getX(y));break;case 2:_=ko(Yo.fromBufferAttribute(P,y));break;case 3:_=hs(yn.fromBufferAttribute(P,y));break;case 4:_=Fo(Qo.fromBufferAttribute(P,y));break}m!==""&&(m+="|"),m+=_}return m}}}class qe extends D{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new it,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,s=e.elements;for(let r=0;r<16;r++)if(n[r]!==s[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=js();if(n)for(const s in e){const r=e[s];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=Ro(r.array)}if(t.boundsTree||(Uo(t,{useSharedArrayBuffer:n}),t.boundsTree=new Hn(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Zo(t)),!t.groupIndices){const s=On(t),r=new Uint16Array(s),i=t.groups;for(let c=0,a=i.length;c<a;c++){const{start:f,count:l}=i[c];for(let h=f/3,u=(f+l)/3;h<u;h++)r[h]=c}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Wo=1e-14,xn=new I,gs=new I,xs=new I;function Mt(o,t=Wo){xn.subVectors(o.b,o.a),gs.subVectors(o.c,o.a),xs.subVectors(o.b,o.c);const e=xn.angleTo(gs),n=xn.angleTo(xs),s=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(s)<t||o.a.distanceToSquared(o.b)<t||o.a.distanceToSquared(o.c)<t||o.b.distanceToSquared(o.c)<t}const wn=1e-10,le=1e-10,Ko=1e-10,dt=new ot,O=new ot,mt=new I,bn=new I,ws=new I,Le=new Rn,Sn=new rt;class Jo{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new Q),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class tr{constructor(){this.trianglePool=new Jo,this.triangles=[],this.normal=new I,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:s}=this;if(Array.isArray(t))for(let r=0,i=t.length;r<i;r++){const c=t[r];if(r===0)c.getNormal(s);else if(Math.abs(1-c.getNormal(mt).dot(s))>wn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const a=n.getTriangle();a.copy(c),e.push(a)}else{t.getNormal(s);const r=n.getTriangle();r.copy(t),e.push(r)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(bn).normalize(),Math.abs(1-Math.abs(bn.dot(e)))<Ko){this.coplanarTriangleUsed=!0;for(let r=0,i=n.length;r<i;r++){const c=n[r];c.coplanarCount=0}const s=[t.a,t.b,t.c];for(let r=0;r<3;r++){const i=(r+1)%3,c=s[r],a=s[i];mt.subVectors(a,c).normalize(),ws.crossVectors(bn,mt),Le.setFromNormalAndCoplanarPoint(ws,c),this.splitByPlane(Le,t)}}else t.getPlane(Le),this.splitByPlane(Le,t)}splitByPlane(t,e){const{triangles:n,trianglePool:s}=this;Sn.copy(e),Sn.needsUpdate=!0;for(let r=0,i=n.length;r<i;r++){const c=n[r];if(!Sn.intersectsTriangle(c,dt,!0))continue;const{a,b:f,c:l}=c;let h=0,u=-1,p=!1,S=[],A=[];const w=[a,f,l];for(let x=0;x<3;x++){const g=(x+1)%3;dt.start.copy(w[x]),dt.end.copy(w[g]);const d=t.distanceToPoint(dt.start),y=t.distanceToPoint(dt.end);if(Math.abs(d)<le&&Math.abs(y)<le){p=!0;break}if(d>0?S.push(x):A.push(x),Math.abs(d)<le)continue;let m=!!t.intersectLine(dt,mt);!m&&Math.abs(y)<le&&(mt.copy(dt.end),m=!0),m&&!(mt.distanceTo(dt.start)<wn)&&(mt.distanceTo(dt.end)<wn&&(u=x),h===0?O.start.copy(mt):O.end.copy(mt),h++)}if(!p&&h===2&&O.distance()>le)if(u!==-1){u=(u+1)%3;let x=0;x===u&&(x=(x+1)%3);let g=x+1;g===u&&(g=(g+1)%3);const d=s.getTriangle();d.a.copy(w[g]),d.b.copy(O.end),d.c.copy(O.start),Mt(d)||n.push(d),c.a.copy(w[x]),c.b.copy(O.start),c.c.copy(O.end),Mt(c)&&(n.splice(r,1),r--,i--)}else{const x=S.length>=2?A[0]:S[0];if(x===0){let T=O.start;O.start=O.end,O.end=T}const g=(x+1)%3,d=(x+2)%3,y=s.getTriangle(),m=s.getTriangle();w[g].distanceToSquared(O.start)<w[d].distanceToSquared(O.end)?(y.a.copy(w[g]),y.b.copy(O.start),y.c.copy(O.end),m.a.copy(w[g]),m.b.copy(w[d]),m.c.copy(O.start)):(y.a.copy(w[d]),y.b.copy(O.start),y.c.copy(O.end),m.a.copy(w[g]),m.b.copy(w[d]),m.c.copy(O.end)),c.a.copy(w[x]),c.b.copy(O.end),c.c.copy(O.start),Mt(y)||n.push(y),Mt(m)||n.push(m),Mt(c)&&(n.splice(r,1),r--,i--)}else h===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function er(o){return o=~~o,o+4-o%4}class bs{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=js()?SharedArrayBuffer:ArrayBuffer,s=new e(new n(er(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,r=t.length;s<r;s++)e[n+s]=t[s];this.length+=t.length}clear(){this.length=0}}class nr{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let s=0;for(let r=0;r<e;r++){const i=n[r];s+=i[t].length}return s}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const s={};e.push(s);for(const r in n){const i=n[r],c=new bs(i.type);c.itemSize=i.itemSize,c.normalized=i.normalized,s[r]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,s){const{groupAttributes:r}=this,c=r[0][t];if(c){if(c.type!==e)for(let a=0,f=r.length;a<f;a++){const l=r[a][t];l.setType(e),l.itemSize=n,l.normalized=s}}else for(let a=0,f=r.length;a<f;a++){const l=new bs(e);l.itemSize=n,l.normalized=s,r[a][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Ss{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:s}=this;n[t]||(n[t]=[],s.push(t)),n[t].push(e)}}const Gs=0,qs=1,sr=2,Ys=3,ir=4,Qs=5,Zs=6,J=new Ls,As=new it,G=new Q,yt=new I,Ts=new $t,Ps=new $t,_s=new $t,An=new $t,Re=new $t,Ne=new $t,vs=new ot,Tn=new I,Pn=1e-8,or=1e-15,Ht=-1,Ot=1,$e=-2,Ve=2,me=0,Rt=1,Xn=2,rr=1e-14;let je=null;function Cs(o){je=o}function Ws(o,t){o.getMidpoint(J.origin),o.getNormal(J.direction);const e=t.raycastFirst(J,Qe);return!!(e&&J.direction.dot(e.face.normal)>0)?Ht:Ot}function ar(o,t){function e(){return Math.random()-.5}o.getNormal(Tn),J.direction.copy(Tn),o.getMidpoint(J.origin);const n=3;let s=0,r=1/0;for(let i=0;i<n;i++){J.direction.x+=e()*Pn,J.direction.y+=e()*Pn,J.direction.z+=e()*Pn,J.direction.multiplyScalar(-1);const c=t.raycastFirst(J,Qe);if(!!(c&&J.direction.dot(c.face.normal)>0)&&s++,c!==null&&(r=Math.min(r,c.distance)),r<=or)return c.face.normal.dot(Tn)>0?Ve:$e;if(s/n>.5||(i-s+1)/n>.5)break}return s/n>.5?Ht:Ot}function cr(o,t){const e=new Ss,n=new Ss;return As.copy(o.matrixWorld).invert().multiply(t.matrixWorld),o.geometry.boundsTree.bvhcast(t.geometry.boundsTree,As,{intersectsTriangles(s,r,i,c){if(!Mt(s)&&!Mt(r)){let a=s.intersectsTriangle(r,vs,!0);if(!a){const f=s.plane,l=r.plane,h=f.normal,u=l.normal;h.dot(u)===1&&Math.abs(f.constant-l.constant)<rr&&(a=!0)}if(a){let f=o.geometry.boundsTree.resolveTriangleIndex(i),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(f,l),n.add(l,f),je&&(je.addEdge(vs),je.addIntersectingTriangles(i,s,c,r))}}return!1}}),{aIntersections:e,bIntersections:n}}function lr(o,t,e,n,s,r,i=!1){const c=e.attributes,a=e.index,f=o*3,l=a.getX(f+0),h=a.getX(f+1),u=a.getX(f+2);for(const p in r){const S=c[p],A=r[p];if(!(p in c))throw new Error(`CSG Operations: Attribute ${p} not available on geometry.`);const w=S.itemSize;p==="position"?(G.a.fromBufferAttribute(S,l).applyMatrix4(n),G.b.fromBufferAttribute(S,h).applyMatrix4(n),G.c.fromBufferAttribute(S,u).applyMatrix4(n),_n(G.a,G.b,G.c,t,3,A,i)):p==="normal"?(G.a.fromBufferAttribute(S,l).applyNormalMatrix(s),G.b.fromBufferAttribute(S,h).applyNormalMatrix(s),G.c.fromBufferAttribute(S,u).applyNormalMatrix(s),i&&(G.a.multiplyScalar(-1),G.b.multiplyScalar(-1),G.c.multiplyScalar(-1)),_n(G.a,G.b,G.c,t,3,A,i,!0)):(Ts.fromBufferAttribute(S,l),Ps.fromBufferAttribute(S,h),_s.fromBufferAttribute(S,u),_n(Ts,Ps,_s,t,w,A,i))}}function ur(o,t,e,n,s,r,i,c=!1){vn(o,n,s,r,i,c),vn(c?e:t,n,s,r,i,c),vn(c?t:e,n,s,r,i,c)}function Ks(o,t,e=!1){switch(o){case Gs:if(t===Ot||t===Ve&&!e)return Rt;break;case qs:if(e){if(t===Ht)return me}else if(t===Ot||t===$e)return Rt;break;case sr:if(e){if(t===Ot||t===$e)return Rt}else if(t===Ht)return me;break;case ir:if(t===Ht)return me;if(t===Ot)return Rt;break;case Ys:if(t===Ht||t===Ve&&!e)return Rt;break;case Qs:if(!e&&(t===Ot||t===$e))return Rt;break;case Zs:if(!e&&(t===Ht||t===Ve))return Rt;break;default:throw new Error(`Unrecognized CSG operation enum "${o}".`)}return Xn}function _n(o,t,e,n,s,r,i=!1,c=!1){const a=f=>{r.push(f.x),s>1&&r.push(f.y),s>2&&r.push(f.z),s>3&&r.push(f.w)};An.set(0,0,0,0).addScaledVector(o,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),Re.set(0,0,0,0).addScaledVector(o,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),Ne.set(0,0,0,0).addScaledVector(o,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),c&&(An.normalize(),Re.normalize(),Ne.normalize()),a(An),i?(a(Ne),a(Re)):(a(Re),a(Ne))}function vn(o,t,e,n,s,r=!1){for(const i in s){const c=t[i],a=s[i];if(!(i in t))throw new Error(`CSG Operations: Attribute ${i} no available on geometry.`);const f=c.itemSize;i==="position"?(yt.fromBufferAttribute(c,o).applyMatrix4(e),a.push(yt.x,yt.y,yt.z)):i==="normal"?(yt.fromBufferAttribute(c,o).applyNormalMatrix(n),r&&yt.multiplyScalar(-1),a.push(yt.x,yt.y,yt.z)):(a.push(c.getX(o)),f>1&&a.push(c.getY(o)),f>2&&a.push(c.getZ(o)),f>3&&a.push(c.getW(o)))}}class fr{constructor(t){this.triangle=new Q().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new Q().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class Ms{constructor(){this.data={}}addTriangleIntersection(t,e,n,s){const{data:r}=this;r[t]||(r[t]=new fr(e)),r[t].addTriangle(n,s)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const s in e)n.push(e[s].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,s=new Set,r=[],i=c=>{if(n[c])if(e!==null)n[c].intersects[e]&&r.push(n[c].intersects[e]);else{const a=n[c].intersects;for(const f in a)s.has(f)||(s.add(f),r.push(a[f]))}};if(t!==null)i(t);else for(const c in n)i(c);return r}reset(){this.data={}}}class hr{constructor(){this.enabled=!1,this.triangleIntersectsA=new Ms,this.triangleIntersectsB=new Ms,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,s){const{triangleIntersectsA:r,triangleIntersectsB:i}=this;r.addTriangleIntersection(t,e,n,s),i.addTriangleIntersection(n,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Cs(this))}complete(){this.enabled&&Cs(null)}}const It=new it,Ye=new li,Nt=new Q,Ue=new Q,vt=new Q,He=new Q,ct=[],Xt=[];function pr(o){for(const t of o)return t}function dr(o,t,e,n,s,r={}){const{useGroups:i=!0}=r,{aIntersections:c,bIntersections:a}=cr(o,t),f=[];let l=null,h;return h=i?0:-1,Es(o,t,c,e,!1,n,s,h),Is(o,t,c,e,!1,s,h),e.findIndex(p=>p!==Zs&&p!==Qs)!==-1&&(h=i?o.geometry.groups.length||1:-1,Es(t,o,a,e,!0,n,s,h),Is(t,o,a,e,!0,s,h)),ct.length=0,Xt.length=0,{groups:f,materials:l}}function Es(o,t,e,n,s,r,i,c=0){const a=o.matrixWorld.determinant()<0;It.copy(t.matrixWorld).invert().multiply(o.matrixWorld),Ye.getNormalMatrix(o.matrixWorld).multiplyScalar(a?-1:1);const f=o.geometry.groupIndices,l=o.geometry.index,h=o.geometry.attributes.position,u=t.geometry.boundsTree,p=t.geometry.index,S=t.geometry.attributes.position,A=e.ids,w=e.intersectionSet;for(let x=0,g=A.length;x<g;x++){const d=A[x],y=c===-1?0:f[d]+c,m=3*d,T=l.getX(m+0),b=l.getX(m+1),P=l.getX(m+2);Nt.a.fromBufferAttribute(h,T).applyMatrix4(It),Nt.b.fromBufferAttribute(h,b).applyMatrix4(It),Nt.c.fromBufferAttribute(h,P).applyMatrix4(It),r.reset(),r.initialize(Nt);const _=w[d];for(let E=0,v=_.length;E<v;E++){const C=3*_[E],B=p.getX(C+0),z=p.getX(C+1),k=p.getX(C+2);Ue.a.fromBufferAttribute(S,B),Ue.b.fromBufferAttribute(S,z),Ue.c.fromBufferAttribute(S,k),r.splitByTriangle(Ue)}const M=r.triangles;for(let E=0,v=M.length;E<v;E++){const C=M[E],B=r.coplanarTriangleUsed?ar(C,u):Ws(C,u);ct.length=0,Xt.length=0;for(let z=0,k=n.length;z<k;z++){const F=Ks(n[z],B,s);F!==Xn&&(Xt.push(F),ct.push(i[z].getGroupAttrSet(y)))}if(ct.length!==0){Nt.getBarycoord(C.a,He.a),Nt.getBarycoord(C.b,He.b),Nt.getBarycoord(C.c,He.c);for(let z=0,k=ct.length;z<k;z++){const F=ct[z],R=Xt[z]===me;lr(d,He,o.geometry,o.matrixWorld,Ye,F,a!==R)}}}}return A.length}function Is(o,t,e,n,s,r,i=0){const c=o.matrixWorld.determinant()<0;It.copy(t.matrixWorld).invert().multiply(o.matrixWorld),Ye.getNormalMatrix(o.matrixWorld).multiplyScalar(c?-1:1);const a=t.geometry.boundsTree,f=o.geometry.groupIndices,l=o.geometry.index,h=o.geometry.attributes,u=h.position,p=[],S=o.geometry.halfEdges,A=new Set,w=On(o.geometry);for(let x=0,g=w;x<g;x++)x in e.intersectionSet||A.add(x);for(;A.size>0;){const x=pr(A);A.delete(x),p.push(x);const g=3*x,d=l.getX(g+0),y=l.getX(g+1),m=l.getX(g+2);vt.a.fromBufferAttribute(u,d).applyMatrix4(It),vt.b.fromBufferAttribute(u,y).applyMatrix4(It),vt.c.fromBufferAttribute(u,m).applyMatrix4(It);const T=Ws(vt,a);Xt.length=0,ct.length=0;for(let b=0,P=n.length;b<P;b++){const _=Ks(n[b],T,s);_!==Xn&&(Xt.push(_),ct.push(r[b]))}for(;p.length>0;){const b=p.pop();for(let P=0;P<3;P++){const _=S.getSiblingTriangleIndex(b,P);_!==-1&&A.has(_)&&(p.push(_),A.delete(_))}if(ct.length!==0){const P=3*b,_=l.getX(P+0),M=l.getX(P+1),E=l.getX(P+2),v=i===-1?0:f[b]+i;if(vt.a.fromBufferAttribute(u,_),vt.b.fromBufferAttribute(u,M),vt.c.fromBufferAttribute(u,E),!Mt(vt))for(let C=0,B=ct.length;C<B;C++){const z=Xt[C],k=ct[C].getGroupAttrSet(v),F=z===me;ur(_,M,E,h,o.matrixWorld,Ye,k,F!==c)}}}}}function mr(o){for(let t=0;t<o.length-1;t++){const e=o[t],n=o[t+1];if(e.materialIndex===n.materialIndex){const s=e.start,r=n.start+n.count;n.start=s,n.count=r-s,o.splice(t,1),t--}}}function yr(o,t,e,n){e.clear();const s=o.attributes;for(let r=0,i=n.length;r<i;r++){const c=n[r],a=s[c];e.initializeArray(c,a.array.constructor,a.itemSize,a.normalized)}for(const r in e.attributes)n.includes(r)||e.delete(r);for(const r in t.attributes)n.includes(r)||(t.deleteAttribute(r),t.dispose())}function gr(o,t,e){let n=!1,s=-1;const r=o.attributes,i=t.groupAttributes[0];for(const a in i){const f=t.getTotalLength(a),l=t.getType(a),h=t.getItemSize(a),u=t.getNormalized(a);let p=r[a];(!p||p.array.length<f)&&(p=new Ze(new l(f),h,u),o.setAttribute(a,p),n=!0);let S=0;for(let A=0,w=Math.min(e.length,t.groupCount);A<w;A++){const x=e[A].index,{array:g,type:d,length:y}=t.groupAttributes[x][a],m=new d(g.buffer,0,y);p.array.set(m,S),S+=m.length}p.needsUpdate=!0,s=f/p.itemSize}if(o.index){const a=o.index.array;if(a.length<s)o.index=null,n=!0;else for(let f=0,l=a.length;f<l;f++)a[f]=f}let c=0;o.clearGroups();for(let a=0,f=Math.min(e.length,t.groupCount);a<f;a++){const{index:l,materialIndex:h}=e[a],u=t.getCount(l);u!==0&&(o.addGroup(c,u,h),c+=u)}o.setDrawRange(0,s),o.boundsTree=null,n&&o.dispose()}function Bs(o,t){let e=t;return Array.isArray(t)||(e=[],o.forEach(n=>{e[n.materialIndex]=t})),e}class xr{constructor(){this.triangleSplitter=new tr,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new hr}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,s=new qe){let r=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s],r=!1),s.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:i,attributeData:c,attributes:a,useGroups:f,consolidateGroups:l,debug:h}=this;for(;c.length<s.length;)c.push(new nr);s.forEach((x,g)=>{yr(t.geometry,x.geometry,c[g],a)}),h.init(),dr(t,e,n,i,c,{useGroups:f}),h.complete();const u=this.getGroupRanges(t.geometry),p=Bs(u,t.material),S=this.getGroupRanges(e.geometry),A=Bs(S,e.material);S.forEach(x=>x.materialIndex+=p.length);let w=[...u,...S].map((x,g)=>({...x,index:g}));if(f){const x=[...p,...A];l&&(w=w.map(d=>{const y=x[d.materialIndex];return d.materialIndex=x.indexOf(y),d}).sort((d,y)=>d.materialIndex-y.materialIndex));const g=[];for(let d=0,y=x.length;d<y;d++){let m=!1;for(let T=0,b=w.length;T<b;T++){const P=w[T];P.materialIndex===d&&(m=!0,P.materialIndex=g.length)}m&&g.push(x[d])}s.forEach(d=>{d.material=g})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(x=>{x.material=p[0]});return s.forEach((x,g)=>{const d=x.geometry;gr(d,c[g],w),l&&mr(d.groups)}),r?s:s[0]}evaluateHierarchy(t,e=new qe){t.updateMatrixWorld(!0);const n=(r,i)=>{const c=r.children;for(let a=0,f=c.length;a<f;a++){const l=c[a];l.isOperationGroup?n(l,i):i(l)}},s=r=>{const i=r.children;let c=!1;for(let f=0,l=i.length;f<l;f++){const h=i[f];c=s(h)||c}const a=r.isDirty();if(a&&r.markUpdated(),c&&!r.isOperationGroup){let f;return n(r,l=>{f?f=this.evaluate(f,l,l.operation):f=this.evaluate(r,l,l.operation)}),r._cachedGeometry=f.geometry,r._cachedMaterials=f.material,!0}else return c||a};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}console.log(" clayModeler.js loaded");class wr{constructor(){this.isOpen=!1,this.panel=null,this.canvasContainer=null,this.scene=null,this.camera=null,this.renderer=null,this.controls=null,this.transformControls=null,this.shapes=[],this.selectedShape=null,this.secondarySelectedShape=null,this.previewMesh=null,this.csgEvaluator=new xr,this.transformMode="translate",this.currentPrimitive="box",this.currentOperation="union",this.currentMaterial=new ui({color:5025616,metalness:.3,roughness:.6}),this.animationFrame=null,console.log(" ClayModeler initialized")}open(){if(this.isOpen)return;console.log(" Opening Clay Modeler..."),this.panel=document.createElement("div"),this.panel.id="clayModelerPanel",this.panel.style.cssText=`
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 900px;
      height: 700px;
      background: rgba(20, 20, 20, 0.98);
      border: 2px solid #4CAF50;
      border-radius: 12px;
      padding: 20px;
      z-index: 2000;
      font-family: 'Courier New', monospace;
      color: #fff;
      box-shadow: 0 0 50px rgba(76, 175, 80, 0.8);
      display: flex;
      flex-direction: column;
    `;const t=this.createTitleBar();this.panel.appendChild(t);const e=document.createElement("div");e.style.cssText=`
      display: flex;
      flex: 1;
      gap: 15px;
      overflow: hidden;
    `;const n=this.createToolPanel();e.appendChild(n);const s=this.createViewportPanel();e.appendChild(s),this.panel.appendChild(e),document.body.appendChild(this.panel),this.isOpen=!0,setTimeout(()=>{this.initThreeJS(),this.startRenderLoop()},100),console.log(" Clay Modeler opened")}createTitleBar(){const t=document.createElement("div");t.style.cssText=`
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #4CAF50;
    `;const e=document.createElement("div");e.style.cssText=`
      font-size: 16px;
      font-weight: bold;
      color: #4CAF50;
      text-transform: uppercase;
      letter-spacing: 2px;
    `,e.textContent=" Clay Modeler - 3D Object Creator";const n=document.createElement("button");return n.textContent="",n.style.cssText=`
      background: none;
      border: 1px solid #4CAF50;
      color: #4CAF50;
      font-size: 20px;
      cursor: pointer;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      transition: all 0.2s;
    `,n.onmouseover=()=>{n.style.background="#4CAF50",n.style.color="#000"},n.onmouseout=()=>{n.style.background="none",n.style.color="#4CAF50"},n.onclick=()=>this.close(),t.appendChild(e),t.appendChild(n),t}createToolPanel(){const t=document.createElement("div");t.style.cssText=`
      width: 250px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    `;const e=this.createSection("Primitives",[this.createButton("Box",()=>this.createPrimitive("box")),this.createButton("Sphere",()=>this.createPrimitive("sphere")),this.createButton("Cylinder",()=>this.createPrimitive("cylinder")),this.createButton("Cone",()=>this.createPrimitive("cone")),this.createButton("Torus",()=>this.createPrimitive("torus"))]);t.appendChild(e);const n=this.createSection("CSG Operations",[this.createButton("Union (Combine)",()=>this.performCSG("union"),"#4CAF50"),this.createButton("Subtract",()=>this.performCSG("subtract"),"#FF5722"),this.createButton("Intersect",()=>this.performCSG("intersect"),"#2196F3")]);t.appendChild(n);const s=this.createSection("Transform Selected",[this.createButton("Move",()=>this.setTransformMode("translate")),this.createButton("Rotate",()=>this.setTransformMode("rotate")),this.createButton("Scale",()=>this.setTransformMode("scale")),this.createButton("Delete",()=>this.deleteSelected(),"#f44336")]);t.appendChild(s);const r=this.createSection("Export",[this.createButton("Save to Destination",()=>this.saveToDestination(),"#FFD700"),this.createButton("View Saved Objects",()=>this.viewSavedObjects(),"#2196F3"),this.createButton("Clear All",()=>this.clearAll(),"#757575")]);return t.appendChild(r),t}createSection(t,e){const n=document.createElement("div");n.style.cssText=`
      display: flex;
      flex-direction: column;
      gap: 8px;
    `;const s=document.createElement("div");return s.style.cssText=`
      font-size: 12px;
      color: #4CAF50;
      font-weight: bold;
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    `,s.textContent=t,n.appendChild(s),e.forEach(r=>n.appendChild(r)),n}createButton(t,e,n="#4CAF50"){const s=document.createElement("button");return s.textContent=t,s.style.cssText=`
      background: rgba(${this.hexToRgb(n)}, 0.2);
      border: 1px solid ${n};
      color: ${n};
      padding: 10px 15px;
      font-size: 11px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s;
      font-family: 'Courier New', monospace;
      font-weight: bold;
    `,s.onmouseover=()=>{s.style.background=n,s.style.color="#000"},s.onmouseout=()=>{s.style.background=`rgba(${this.hexToRgb(n)}, 0.2)`,s.style.color=n},s.onclick=e,s}hexToRgb(t){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return e?`${parseInt(e[1],16)}, ${parseInt(e[2],16)}, ${parseInt(e[3],16)}`:"76, 175, 80"}createViewportPanel(){const t=document.createElement("div");t.style.cssText=`
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #333;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    `,this.canvasContainer=document.createElement("div"),this.canvasContainer.style.cssText=`
      width: 100%;
      height: 100%;
    `,t.appendChild(this.canvasContainer);const e=document.createElement("div");return e.style.cssText=`
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 4px;
      font-size: 10px;
      color: #aaa;
      line-height: 1.4;
      pointer-events: none;
    `,e.innerHTML=`
      <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">Controls:</div>
      <div> Left click + drag: Rotate view</div>
      <div> Right click + drag: Pan view</div>
      <div> Scroll: Zoom in/out</div>
      <div> Click object: Select (primary)</div>
      <div> Shift+Click object: Select (secondary for CSG)</div>
      <div style="color: #4CAF50; font-weight: bold; margin-top: 8px; margin-bottom: 3px;">Transform (when selected):</div>
      <div> W: Translate mode</div>
      <div> E: Rotate mode</div>
      <div> R: Scale mode</div>
      <div> +/-: Gizmo size</div>
      <div style="color: #4CAF50; font-weight: bold; margin-top: 8px; margin-bottom: 3px;">CSG Operations:</div>
      <div> Select 2 shapes (primary + secondary)</div>
      <div> Click Union, Subtract, or Intersect</div>
    `,t.appendChild(e),t}initThreeJS(){console.log(" Initializing Three.js scene..."),this.scene=new fi,this.scene.background=new hi(1710618);const t=this.canvasContainer.clientWidth,e=this.canvasContainer.clientHeight;this.camera=new pi(60,t/e,.1,1e3),this.camera.position.set(5,5,5),this.camera.lookAt(0,0,0),this.renderer=new di({antialias:!0}),this.renderer.setSize(t,e),this.renderer.setPixelRatio(window.devicePixelRatio),this.canvasContainer.appendChild(this.renderer.domElement),this.controls=new mi(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.transformControls=new bi(this.camera,this.renderer.domElement),this.transformControls.setMode(this.transformMode),this.transformControls.setSize(.8),this.scene.add(this.transformControls),this.transformControls.addEventListener("dragging-changed",a=>{this.controls.enabled=!a.value}),this.transformControls.addEventListener("objectChange",()=>{});const n=new yi(10,10,4473924,2236962);this.scene.add(n);const s=new gi(2);this.scene.add(s);const r=new xi(16777215,.5);this.scene.add(r);const i=new Gn(16777215,.8);i.position.set(5,5,5),this.scene.add(i);const c=new Gn(4474111,.3);c.position.set(-5,-3,-5),this.scene.add(c),this.raycaster=new zs,this.mouse=new ht,this.renderer.domElement.addEventListener("click",a=>{this.onCanvasClick(a)}),console.log(" Three.js scene initialized",{width:t,height:e})}startRenderLoop(){const t=()=>{this.isOpen&&(this.animationFrame=requestAnimationFrame(t),this.controls&&this.controls.update(),this.renderer&&this.scene&&this.camera&&this.renderer.render(this.scene,this.camera))};t()}createPrimitive(t){console.log(` Creating primitive: ${t}`);let e;switch(t){case"box":e=new V(1,1,1);break;case"sphere":e=new ks(.6,32,32);break;case"cylinder":e=new q(.5,.5,1,32);break;case"cone":e=new wi(.5,1,32);break;case"torus":e=new Kt(.5,.2,16,32);break;default:console.error(`Unknown primitive type: ${t}`);return}const n=this.currentMaterial.clone(),s=new D(e,n);this.shapes.length>0&&(s.position.x=Math.random()*2-1,s.position.z=Math.random()*2-1),this.scene.add(s),this.shapes.push({mesh:s,type:t,id:Date.now()}),this.selectShape(s),console.log(` Created ${t} at`,s.position)}selectShape(t,e=!1){e?(this.secondarySelectedShape&&this.secondarySelectedShape.material.emissive.setHex(0),this.secondarySelectedShape=t,t&&t.material.emissive.setHex(4473856)):(this.selectedShape&&this.selectedShape.material.emissive.setHex(0),this.selectedShape=t,t?(t.material.emissive.setHex(4473924),this.transformControls&&this.transformControls.attach(t)):this.transformControls&&this.transformControls.detach())}onCanvasClick(t){const e=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(t.clientX-e.left)/e.width*2-1,this.mouse.y=-((t.clientY-e.top)/e.height)*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const n=this.shapes.map(r=>r.mesh),s=this.raycaster.intersectObjects(n);if(s.length>0){const r=t.shiftKey;this.selectShape(s[0].object,r),console.log(` Selected shape ${r?"(secondary)":"(primary)"}:`,s[0].object)}else t.shiftKey?this.selectShape(null,!0):this.selectShape(null,!1)}performCSG(t){if(console.log(` Performing CSG operation: ${t}`),this.shapes.length<2){alert("Need at least 2 shapes for CSG operations");return}if(!this.selectedShape){alert("Please select a primary shape first (left click)");return}if(!this.secondarySelectedShape){alert("Please select a secondary shape (Shift+click on another shape)");return}if(this.selectedShape===this.secondarySelectedShape){alert("Cannot perform CSG on the same shape. Select two different shapes.");return}console.log(` Performing ${t}: ${this.selectedShape.userData.name||"shape"}  ${this.secondarySelectedShape.userData.name||"shape"}`);try{const e=new qe(this.selectedShape.geometry,this.selectedShape.material);e.position.copy(this.selectedShape.position),e.rotation.copy(this.selectedShape.rotation),e.scale.copy(this.selectedShape.scale),e.updateMatrixWorld();const n=new qe(this.secondarySelectedShape.geometry,this.secondarySelectedShape.material);n.position.copy(this.secondarySelectedShape.position),n.rotation.copy(this.secondarySelectedShape.rotation),n.scale.copy(this.secondarySelectedShape.scale),n.updateMatrixWorld();let s;switch(t){case"union":s=this.csgEvaluator.evaluate(e,n,Gs);break;case"subtract":s=this.csgEvaluator.evaluate(e,n,qs);break;case"intersect":s=this.csgEvaluator.evaluate(e,n,Ys);break;default:alert(`Unknown CSG operation: ${t}`);return}const r=this.currentMaterial.clone(),i=new D(s.geometry,r);i.userData.name=`CSG_${t}_${Date.now()}`,this.scene.add(i),this.shapes.push({mesh:i,type:`csg_${t}`,id:Date.now()}),this.scene.remove(this.selectedShape),this.scene.remove(this.secondarySelectedShape),this.selectedShape.geometry.dispose(),this.selectedShape.material.dispose(),this.secondarySelectedShape.geometry.dispose(),this.secondarySelectedShape.material.dispose(),this.shapes=this.shapes.filter(c=>c.mesh!==this.selectedShape&&c.mesh!==this.secondarySelectedShape),this.selectedShape=null,this.secondarySelectedShape=null,this.selectShape(i),console.log(` CSG ${t} completed successfully`)}catch(e){console.error(" CSG operation failed:",e),alert(`CSG ${t} failed: ${e.message}`)}}setTransformMode(t){if(!["translate","rotate","scale"].includes(t)){console.error(`Invalid transform mode: ${t}`);return}this.transformMode=t,this.transformControls&&this.transformControls.setMode(t),console.log(` Transform mode set to: ${t}`)}deleteSelected(){if(!this.selectedShape){alert("No shape selected");return}console.log(" Deleting selected shape"),this.scene.remove(this.selectedShape),this.selectedShape.geometry.dispose(),this.selectedShape.material.dispose(),this.shapes=this.shapes.filter(t=>t.mesh!==this.selectedShape),this.selectedShape=null}clearAll(){confirm("Clear all shapes? This cannot be undone.")&&(console.log(" Clearing all shapes"),this.shapes.forEach(t=>{this.scene.remove(t.mesh),t.mesh.geometry.dispose(),t.mesh.material.dispose()}),this.shapes=[],this.selectedShape=null)}saveToDestination(){if(console.log(" saveToDestination() called"),this.shapes.length===0){console.warn(" No shapes to save"),alert("No shapes to save");return}if(console.log(` Have ${this.shapes.length} shapes to save`),!window.destinationAuthoring){console.error(" window.destinationAuthoring not available"),alert(`Destination authoring system not available.

Make sure the main scene is loaded first.`);return}console.log(" destinationAuthoring available, getting destinations...");let t;try{t=window.destinationAuthoring.getAllDestinations(),console.log(` Found ${t.length} destinations`,t)}catch(e){console.error(" Error getting destinations:",e),alert(`Error getting destinations: ${e.message}`);return}if(t.length===0){alert(` No destinations found.

Create a destination first using the HUD panel, then reopen Clay Modeler.`);return}this.showDestinationPicker(t)}showDestinationPicker(t){const e=document.createElement("div");e.style.cssText=`
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;const n=document.createElement("div");n.style.cssText=`
      background: #1a1a1a;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      padding: 20px;
      max-width: 500px;
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
    `;const s=document.createElement("h2");s.textContent="Select Destination",s.style.cssText=`
      color: #4CAF50;
      margin: 0 0 15px 0;
      font-size: 18px;
      font-family: 'Courier New', monospace;
    `,n.appendChild(s);const r=document.createElement("p");r.textContent=`Saving ${this.shapes.length} shape(s)`,r.style.cssText=`
      color: #888;
      margin: 0 0 20px 0;
      font-size: 12px;
      font-family: 'Courier New', monospace;
    `,n.appendChild(r);const i=document.createElement("div");i.style.cssText=`
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    `,t.forEach(a=>{const f=window.camera?window.camera.position:{x:0,y:0,z:0},l=Math.sqrt(Math.pow(a.position.x-f.x,2)+Math.pow(a.position.y-f.y,2)+Math.pow(a.position.z-f.z,2)),h=document.createElement("button");h.textContent=`${a.name} (${l.toFixed(1)} units)`,h.style.cssText=`
        background: #2a2a2a;
        border: 1px solid #4CAF50;
        color: #fff;
        padding: 12px;
        font-size: 14px;
        font-family: 'Courier New', monospace;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s;
        text-align: left;
      `,h.onmouseover=()=>{h.style.background="#4CAF50",h.style.color="#000"},h.onmouseout=()=>{h.style.background="#2a2a2a",h.style.color="#fff"},h.onclick=()=>{document.body.removeChild(e),this.performSave(a)},i.appendChild(h)}),n.appendChild(i);const c=document.createElement("button");c.textContent="Cancel",c.style.cssText=`
      background: #333;
      border: 1px solid #666;
      color: #fff;
      padding: 10px 20px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 4px;
      width: 100%;
    `,c.onclick=()=>{document.body.removeChild(e)},n.appendChild(c),e.appendChild(n),document.body.appendChild(e)}performSave(t){try{const e={name:`Clay Object ${Date.now()}`,description:`Created with ${this.shapes.length} shape(s)`,shapes:this.shapes.map((s,r)=>{const i=s.mesh.geometry.toJSON(),c={color:"#"+s.mesh.material.color.getHexString(),metalness:s.mesh.material.metalness,roughness:s.mesh.material.roughness,emissive:"#"+s.mesh.material.emissive.getHexString(),emissiveIntensity:s.mesh.material.emissiveIntensity};return{id:s.id,type:s.type,geometry:i,material:c,position:s.mesh.position.toArray(),rotation:[s.mesh.rotation.x,s.mesh.rotation.y,s.mesh.rotation.z],scale:s.mesh.scale.toArray()}}),createdAt:Date.now(),version:"1.0"},n=window.destinationAuthoring.addClayObjectToDestination(t.id,e);n?(alert(` Saved clay object to "${t.name}"!

Object ID: ${n.id}
Shapes: ${this.shapes.length}`),console.log(" Clay object saved:",n),this.showClearWorkspaceDialog()):alert(" Failed to save to destination")}catch(e){console.error(" Failed to save to destination:",e),alert(` Failed to save: ${e.message}`)}}showClearWorkspaceDialog(){const t=document.createElement("div");t.style.cssText=`
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;const e=document.createElement("div");e.style.cssText=`
      background: #1a1a1a;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
    `;const n=document.createElement("p");n.textContent="Clear the modeler workspace?",n.style.cssText=`
      color: #fff;
      margin: 0 0 20px 0;
      font-size: 14px;
      font-family: 'Courier New', monospace;
    `,e.appendChild(n);const s=document.createElement("div");s.style.cssText=`
      display: flex;
      gap: 10px;
    `;const r=document.createElement("button");r.textContent="Yes, Clear",r.style.cssText=`
      background: #4CAF50;
      border: none;
      color: #000;
      padding: 10px 20px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 4px;
      flex: 1;
    `,r.onclick=()=>{this.clearAll(),document.body.removeChild(t)};const i=document.createElement("button");i.textContent="No, Keep",i.style.cssText=`
      background: #333;
      border: 1px solid #666;
      color: #fff;
      padding: 10px 20px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 4px;
      flex: 1;
    `,i.onclick=()=>{document.body.removeChild(t)},s.appendChild(r),s.appendChild(i),e.appendChild(s),t.appendChild(e),document.body.appendChild(t)}viewSavedObjects(){if(!window.destinationAuthoring){alert("Destination authoring system not available");return}console.log(" Viewing saved objects...");const t=window.destinationAuthoring.getAllDestinations();if(t.length===0){alert(`No destinations found.

Create a destination first to save clay objects.`);return}let e=[` Saved Clay Objects:
`],n=!1;if(t.forEach(s=>{s.clayObjects&&s.clayObjects.length>0&&(n=!0,e.push(`
 ${s.name}:`),s.clayObjects.forEach((r,i)=>{var a;const c=new Date(r.createdAt).toLocaleString();e.push(`  ${i+1}. ${r.name}`),e.push(`      Shapes: ${((a=r.shapes)==null?void 0:a.length)||0}`),e.push(`      Created: ${c}`),e.push(`      ID: ${r.id}`)}))}),!n){alert(`No clay objects saved yet.

Create shapes and click "Save to Destination" to save them.`);return}e.push(`

To delete a clay object:`),e.push("Use the Destination HUD panel"),e.push("or use the browser console:"),e.push(`
window.destinationAuthoring.removeClayObjectFromDestination(destinationId, clayObjectId)`),alert(e.join(`
`))}exportJSON(){return{shapes:this.shapes.map(e=>({type:e.type,position:e.mesh.position.toArray(),rotation:e.mesh.rotation.toArray(),scale:e.mesh.scale.toArray()})),version:"1.0"}}close(){this.isOpen&&(console.log(" Closing Clay Modeler..."),this.animationFrame&&(cancelAnimationFrame(this.animationFrame),this.animationFrame=null),this.transformControls&&(this.transformControls.detach(),this.transformControls.dispose(),this.transformControls=null),this.renderer&&(this.renderer.dispose(),this.renderer=null),this.shapes.forEach(t=>{t.mesh.geometry&&t.mesh.geometry.dispose(),t.mesh.material&&t.mesh.material.dispose()}),this.shapes=[],this.selectedShape=null,this.controls=null,this.panel&&this.panel.parentNode&&this.panel.parentNode.removeChild(this.panel),this.panel=null,this.isOpen=!1,console.log(" Clay Modeler closed"))}toggle(){this.isOpen?this.close():this.open()}}const br=new wr;typeof window<"u"&&(window.ClayModeler=br);console.log(" Clay Modeler module ready");export{wr as ClayModeler,br as clayModeler};
//# sourceMappingURL=clayModeler-yOMQIIqC.js.map
