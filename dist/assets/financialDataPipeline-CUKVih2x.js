import{F as O}from"./index-CN57N6UK.js";console.log("ðŸ”® kalmanBifurcationFilter_v2.js loaded");const q=(1+Math.sqrt(5))/2;class Y{constructor(t={}){this.filterType=t.filterType||"UKF",this.s=t.initialState||.99,this.P=t.initialCovariance||.01,this.A=t.A||.95,this.B=t.B||[-.05,-.15],this.H=t.H||1,this.Q=t.Q||1e-4,this.R=t.R||.001,this.ukf={alpha:t.ukfAlpha||.1,beta:t.ukfBeta||2,kappa:t.ukfKappa||0,lambda:0,weights_m:[],weights_c:[]};const e=1;this.ukf.lambda=this.ukf.alpha**2*(e+this.ukf.kappa)-e;const i=this.ukf.lambda+e;this.ukf.weights_m[0]=this.ukf.lambda/i,this.ukf.weights_m[1]=.5/i,this.ukf.weights_m[2]=.5/i,this.ukf.weights_c[0]=this.ukf.lambda/i+(1-this.ukf.alpha**2+this.ukf.beta),this.ukf.weights_c[1]=.5/i,this.ukf.weights_c[2]=.5/i,this.phiTarget=q,this.phiRegWeight=t.phiRegWeight!==void 0?t.phiRegWeight:.1,this.phiLearningRate=t.phiLearningRate||.001,this.history={s:[],y:[],innovation:[],K:[]},console.log("ðŸ”® Kalman Bifurcation Filter V2.0 initialized"),console.log(`   Filter Type: ${this.filterType}`),console.log(`   A = ${this.A.toFixed(4)} (memory)`),console.log(`   B = [${this.B.map(s=>s.toFixed(4)).join(", ")}] (stress)`),console.log(`   Ï†-regularization weight: ${this.phiRegWeight.toFixed(3)}`),this.filterType==="UKF"&&(console.log(`   UKF: Î±=${this.ukf.alpha}, Î²=${this.ukf.beta}, Îº=${this.ukf.kappa}`),console.log(`   UKF: Î»=${this.ukf.lambda.toFixed(4)}, 3 sigma points`))}f(t,e){const[i,s]=e,a=this.A*t[0]+this.B[0]*i+this.B[1]*s;return[Math.tanh(a*1.5)]}h(t){return this.H*t[0]}generateSigmaPoints(t,e){const s=this.ukf.lambda+1,a=[];a[0]=[t];const r=Math.sqrt(s*e);return a[1]=[t+r],a[2]=[t-r],a}predictUKF(t){const i=this.generateSigmaPoints(this.s,this.P).map(r=>this.f(r,t));let s=0;for(let r=0;r<3;r++)s+=this.ukf.weights_m[r]*i[r][0];let a=0;for(let r=0;r<3;r++){const o=i[r][0]-s;a+=this.ukf.weights_c[r]*o*o}return a+=this.Q,{s_pred:s,P_pred:a,sigma_points_pred:i}}updateUKF(t,e,i,s){const a=i.map(u=>this.h(u));let r=0;for(let u=0;u<3;u++)r+=this.ukf.weights_m[u]*a[u];let o=0;for(let u=0;u<3;u++){const g=a[u]-r;o+=this.ukf.weights_c[u]*g*g}o+=this.R;let n=0;for(let u=0;u<3;u++){const g=i[u][0]-t,p=a[u]-r;n+=this.ukf.weights_c[u]*g*p}const m=n/o,c=s-r;let l=t+m*c;l=Math.max(0,Math.min(1,l));const h=e-m*o*m;return{s:l,P:h,K:m,innovation:c}}predictLKF(t){const[e,i]=t,s=this.B[0]*e+this.B[1]*i,a=this.A*this.s+s,r=this.A*this.P*this.A+this.Q;return{s_pred:a,P_pred:r}}updateLKF(t,e,i){const s=i-this.H*t,a=this.H*e*this.H+this.R,r=e*this.H/a;let o=t+r*s;o=Math.max(0,Math.min(1,o));const n=(1-r*this.H)*e;return{s:o,P:n,K:r,innovation:s}}step(t,e){let i,s,a,r;if(this.filterType==="UKF"){const o=this.predictUKF(t);i=o.s_pred,s=o.P_pred;const n=this.updateUKF(i,s,o.sigma_points_pred,e);this.s=n.s,this.P=n.P,a=n.K,r=n.innovation}else{const o=this.predictLKF(t);i=o.s_pred,s=o.P_pred;const n=this.updateLKF(i,s,e);this.s=n.s,this.P=n.P,a=n.K,r=n.innovation}return this.history.s.push(this.s),this.history.y.push(e),this.history.innovation.push(r),this.history.K.push(a),this.history.s.length>100&&(this.history.s.shift(),this.history.y.shift(),this.history.innovation.shift(),this.history.K.shift()),this.phiRegWeight>0&&this.history.s.length>10&&this.applyPhiConstraint(),{sigma_star:this.s,sigma_c:e,innovation:r,kalman_gain:a,confidence:1-this.P,bifurcation_risk:1-this.s}}applyPhiConstraint(){const t=Math.abs(this.B[0])+Math.abs(this.B[1]),e=Math.abs(this.A)/t,i=Math.abs(e-this.phiTarget);if(i>.01&&this.phiRegWeight>0){const s=this.history.innovation.slice(-10);s.reduce((m,c)=>m+c*c,0)/s.length+this.phiRegWeight*i;const r=e-this.phiTarget,n=this.phiLearningRate*this.phiRegWeight*r;this.A=this.A*(1-n*.1),this.B[0]=this.B[0]*(1+n*.1),this.B[1]=this.B[1]*(1+n*.1),this.A=Math.max(.85,Math.min(.99,this.A)),this.B[0]=Math.max(-.2,Math.min(-.01,this.B[0])),this.B[1]=Math.max(-.3,Math.min(-.05,this.B[1]))}}setPhiRegWeight(t){this.phiRegWeight=Math.max(0,Math.min(1,t)),console.log(`ðŸ”® Ï†-regularization weight set to ${this.phiRegWeight.toFixed(3)}`)}setFilterType(t){t==="LKF"||t==="UKF"?(this.filterType=t,console.log(`ðŸ”® Filter type changed to ${t}`)):console.error(`ðŸ”® Invalid filter type: ${t}. Use 'LKF' or 'UKF'`)}getPhiRatio(){const t=Math.abs(this.B[0])+Math.abs(this.B[1]);return Math.abs(this.A)/t}getDiagnostics(){const t=Math.abs(this.B[0])+Math.abs(this.B[1]),e=Math.abs(this.A)/t,i=Math.abs(e-this.phiTarget);return{filter_type:this.filterType,state:this.s,covariance:this.P,matrices:{A:this.A,B:this.B,H:this.H,Q:this.Q,R:this.R},phi:{target:this.phiTarget,current:e,error:i,converged:i<.01,reg_weight:this.phiRegWeight},ukf:this.filterType==="UKF"?{alpha:this.ukf.alpha,beta:this.ukf.beta,kappa:this.ukf.kappa,lambda:this.ukf.lambda}:null,history_length:this.history.s.length}}reset(t=.99){this.s=t,this.P=.01,this.history={s:[],y:[],innovation:[],K:[]},console.log("ðŸ”® Kalman filter reset")}exportState(){return{filterType:this.filterType,s:this.s,P:this.P,A:this.A,B:[...this.B],H:this.H,Q:this.Q,R:this.R,phiRegWeight:this.phiRegWeight}}importState(t){this.filterType=t.filterType||this.filterType,this.s=t.s,this.P=t.P,this.A=t.A,this.B=[...t.B],this.H=t.H,this.Q=t.Q,this.R=t.R,t.phiRegWeight!==void 0&&(this.phiRegWeight=t.phiRegWeight),console.log("ðŸ”® Kalman filter state imported")}}console.log("ðŸ”® KalmanBifurcationFilter V2.0 class ready");console.log("ðŸ’° financialFeatureExtractor.js loaded (V2.0 - UKF + XAI)");class X{constructor(t={}){this.params={kappa:1,lambda:1,z:.8,eta:1,mu:.5,gamma_ent:1,gamma:.5,rho:1,trans_span:5,res_span:10,ent_span:20,hurst_span:40,hurst_window:60,short_vol_window:10,long_vol_window:60,es_quantile:.05,epsilon:1e-8,...t},this.state={priceHistory:[],volumeHistory:[],returnsHistory:[],timestampHistory:[],ewma:{trans_sm:null,res_sm:null,ent_sm:null,hurst_sm:null},lastFeatures:this._getDefaultFeatures()},this.kalmanFilter=new Y({filterType:t.filterType||"UKF",initialState:.99,phiRegWeight:t.phiRegWeight!==void 0?t.phiRegWeight:.1}),this.featureImportanceModule=new O({sigmaC_weights:t.sigmaC_weights}),console.log("ðŸ’° FinancialFeatureExtractor V2.0 initialized"),console.log(`   Filter Type: ${this.kalmanFilter.filterType}`),console.log(`   Ï†-Regularization: ${this.kalmanFilter.phiRegWeight.toFixed(3)}`)}_getDefaultFeatures(){return{timestamp:Date.now(),signal:{source:"financial",dataPoints:0},features:{identity:{fundamentalFreq:0,strength:.5},relationship:{consonance:.5,complexity:.5},complexity:{brightness:.5,centroid:1e3,bandwidth:1e3},transformation:{flux:0,velocity:0,acceleration:0},alignment:{coherence:.5,stability:.5,synchrony:.5},potential:{entropy:.5,unpredictability:0,freedom:.5},resolution:{sigma_C:.5,sigma_R:.5,res_ratio:0}}}}update(t,e=null,i=null){const s=i||Date.now();if(this.state.priceHistory.push(t),this.state.volumeHistory.push(e),this.state.timestampHistory.push(s),this.state.priceHistory.length>=2){const r=this.state.priceHistory[this.state.priceHistory.length-2],o=Math.log(t/r);this.state.returnsHistory.push(o)}else this.state.returnsHistory.push(0);return this.state.priceHistory.length>200&&(this.state.priceHistory.shift(),this.state.volumeHistory.shift(),this.state.returnsHistory.shift(),this.state.timestampHistory.shift()),this.state.lastFeatures=this._computeFeatures(),this.state.lastFeatures}getFeatures(){return this.state.lastFeatures}_computeFeatures(){const t=this._getDefaultFeatures();if(t.timestamp=Date.now(),t.signal.dataPoints=this.state.priceHistory.length,this.state.returnsHistory.length<20)return t;const e=this.state.returnsHistory,i=this.state.volumeHistory,s=this.params.epsilon,a=e[e.length-1];t.features.identity.fundamentalFreq=a*1e3,t.features.identity.strength=Math.min(Math.abs(a),1);const r=this._rollingStd(e,this.params.short_vol_window),o=Math.max(this._rollingStd(e,this.params.long_vol_window),s),n=(r-o)/o,m=Math.min(Math.abs(n),10),c=Math.log1p(m),l=this._updateEWMA("trans_sm",c,this.params.trans_span);t.features.transformation.flux=l,t.features.transformation.velocity=Math.max(-1,Math.min(1,n));const h=this._estimateHurst(e,this.params.hurst_window),u=this._updateEWMA("hurst_sm",h,this.params.hurst_span),g=Math.max(.01,Math.min(.99,u));t.features.complexity.brightness=g,t.features.complexity.centroid=o*1e3,t.features.complexity.bandwidth=r*1e3,t.features.relationship.complexity=g;const p=this._autocorrelation(e,1,20),k=1-Math.abs(p),R=this._updateEWMA("ent_sm",k,this.params.ent_span),y=Math.max(0,Math.min(1,R));t.features.potential.entropy=y,t.features.alignment.coherence=1-y;let f=0;if(i[0]!==null&&i.length>=20){const P=this._rollingMean(i,20);f=(i[i.length-1]-P)/(P+s),f=Math.max(-5,Math.min(5,f))}t.features.relationship.consonance=Math.max(0,Math.min(1,1-Math.abs(f)/5));const B=this._computeExpectedShortfall(e,this.params.long_vol_window,this.params.es_quantile)/(o+s),A=Math.min(B,10),D=Math.log1p(A),S=this._updateEWMA("res_sm",D,this.params.res_span);t.features.potential.unpredictability=S,t.features.resolution.res_ratio=S;const w=g-.5,x=1-this.params.z*y,$=1+this.params.kappa*w*x,I=1+this.params.lambda*w*x,L=1+$*a**2+I*f**2+this.params.eta*l+this.params.gamma_ent*y,H=1+this.params.mu*l,E=Math.pow(1/L,H),v=Math.max(1e-12,Math.min(1,E));t.features.alignment.stability=v,t.features.resolution.sigma_C=v;const V=1/(v+s)+this.params.gamma*S,W=1+this.params.rho*S,N=Math.pow(1/V,W),M=Math.max(1e-12,Math.min(1,N));t.features.alignment.synchrony=M,t.features.resolution.sigma_R=M,t.features.potential.freedom=1-M;const U=[l,S],K=v,b=this.kalmanFilter.step(U,K);t.features.resolution.sigma_star=b.sigma_star,t.features.resolution.bifurcation_risk=b.bifurcation_risk,t.features.resolution.kalman_innovation=b.innovation,t.features.resolution.kalman_confidence=b.confidence,t.features.resolution.phi_ratio=this.kalmanFilter.getPhiRatio();const z={delta_p:a,vol_stress:f,H:g-.5,entropy:y},G=[l,S],j={B:this.kalmanFilter.B},Q=this.featureImportanceModule.calculateFeatureImportance(z,G,j);return t.xai=Q,t}_rollingMean(t,e){return t.length<e?t.reduce((s,a)=>s+a,0)/t.length:t.slice(-e).reduce((s,a)=>s+a,0)/e}_rollingStd(t,e){if(t.length<2)return 0;const i=t.length>=e?t.slice(-e):t,s=i.reduce((r,o)=>r+o,0)/i.length,a=i.reduce((r,o)=>r+(o-s)**2,0)/i.length;return Math.sqrt(a)}_updateEWMA(t,e,i){const s=2/(i+1);return this.state.ewma[t]===null?this.state.ewma[t]=e:this.state.ewma[t]=s*e+(1-s)*this.state.ewma[t],this.state.ewma[t]}_estimateHurst(t,e){if(t.length<e)return .5;try{const i=t.slice(-e),s=i.reduce((h,u)=>h+u,0)/i.length;let a=0;const r=i.map(h=>(a+=h-s,a)),o=Math.max(...r)-Math.min(...r),n=i.reduce((h,u)=>h+(u-s)**2,0)/i.length,m=Math.sqrt(n);if(m===0||o===0)return .5;const c=o/m,l=Math.log(c)/Math.log(e/2);return Math.max(.01,Math.min(.99,l))}catch{return .5}}_autocorrelation(t,e,i){if(t.length<e+i)return 0;const s=t.slice(-i),a=s.reduce((n,m)=>n+m,0)/s.length;let r=0,o=0;for(let n=0;n<s.length-e;n++)r+=(s[n]-a)*(s[n+e]-a);for(let n=0;n<s.length;n++)o+=(s[n]-a)**2;return o===0?0:r/o}_computeExpectedShortfall(t,e,i){if(t.length<e)return 0;const s=t.slice(-e),a=[...s].sort((c,l)=>c-l),r=Math.floor(i*a.length),o=a[r],n=s.filter(c=>c<=o);if(n.length===0)return 0;const m=n.reduce((c,l)=>c+l,0)/n.length;return Math.abs(m)}reset(){this.state.priceHistory=[],this.state.volumeHistory=[],this.state.returnsHistory=[],this.state.timestampHistory=[],this.state.ewma={trans_sm:null,res_sm:null,ent_sm:null,hurst_sm:null},this.state.lastFeatures=this._getDefaultFeatures(),console.log("ðŸ’° Financial extractor state reset")}loadHistoricalData(t){return this.reset(),t.forEach(e=>{this.update(e.price,e.volume||null,e.timestamp||null)}),console.log(`ðŸ’° Loaded ${t.length} historical data points`),this.state.lastFeatures}getStateSummary(){return{dataPoints:this.state.priceHistory.length,latestPrice:this.state.priceHistory[this.state.priceHistory.length-1],latestReturn:this.state.returnsHistory[this.state.returnsHistory.length-1],sigma_R:this.state.lastFeatures.features.resolution.sigma_R,sigma_C:this.state.lastFeatures.features.resolution.sigma_C,hurst:this.state.lastFeatures.features.complexity.brightness}}}console.log("ðŸ’° Financial Feature Extractor module ready");console.log("ðŸŽ¯ regimeClassifier.js loaded");class J{constructor(t={}){this.params={riskCrisisThreshold:t.riskCrisisThreshold??.7,sigmaRCrisisLimit:t.sigmaRCrisisLimit??.08,sigmaStarCrisisLimit:t.sigmaStarCrisisLimit??.3,riskNormalThreshold:t.riskNormalThreshold??.2,sigmaStarRecovery:t.sigmaStarRecovery??.9,hysteresisWindow:t.hysteresisWindow??3,predictionHorizon:t.predictionHorizon??3,predictionAlpha:t.predictionAlpha??.3,phiViolationPenalty:t.phiViolationPenalty??1.2,phiToleranceWindow:t.phiToleranceWindow??.05,smoothingAlpha:t.smoothingAlpha??.3,...t},this.state={currentRegime:"NORMAL",previousRegime:"NORMAL",regimeScore:1,transitionCount:0,ticksSinceTransition:0},this.buffers={sigmaStar:[],sigmaR:[],bifurcationRisk:[],phiRatio:[]},this.smoothed={sigmaStar:null,bifurcationRisk:null,sigmaR:null},this.prediction={expectedSigmaStar:null,expectedRisk:null},console.log("ðŸŽ¯ RegimeClassifier initialized"),console.log(`   Crisis threshold: Risk > ${(this.params.riskCrisisThreshold*100).toFixed(0)}%, Î£R < ${this.params.sigmaRCrisisLimit.toFixed(3)}`),console.log(`   Normal threshold: Risk < ${(this.params.riskNormalThreshold*100).toFixed(0)}%, Î£* > ${this.params.sigmaStarRecovery.toFixed(3)}`)}calculateRegimeState({sigmaStar:t,sigmaR:e,bifurcationRisk:i,phiRatio:s}){this._updateBuffers(t,e,i,s),this._smoothSignals(t,i,e),this._computePredictions();const a=this._applyDecisionLogic();return this._updateState(a),{regimeState:this.state.currentRegime,regimeScore:this.state.regimeScore,confidence:this._computeConfidence(),avgRiskRecent:this._getRecentAverage("bifurcationRisk"),avgSigmaStarRecent:this._getRecentAverage("sigmaStar"),avgSigmaRRecent:this._getRecentAverage("sigmaR"),expectedSigmaStar:this.prediction.expectedSigmaStar,expectedRisk:this.prediction.expectedRisk,transitionCount:this.state.transitionCount,ticksSinceTransition:this.state.ticksSinceTransition,previousRegime:this.state.previousRegime}}_updateBuffers(t,e,i,s){const a=this.params.hysteresisWindow*2;this.buffers.sigmaStar.push(t),this.buffers.sigmaR.push(e),this.buffers.bifurcationRisk.push(i),s!==void 0&&this.buffers.phiRatio.push(s),this.buffers.sigmaStar.length>a&&this.buffers.sigmaStar.shift(),this.buffers.sigmaR.length>a&&this.buffers.sigmaR.shift(),this.buffers.bifurcationRisk.length>a&&this.buffers.bifurcationRisk.shift(),this.buffers.phiRatio.length>a&&this.buffers.phiRatio.shift()}_smoothSignals(t,e,i){const s=this.params.smoothingAlpha;this.smoothed.sigmaStar===null?(this.smoothed.sigmaStar=t,this.smoothed.bifurcationRisk=e,this.smoothed.sigmaR=i):(this.smoothed.sigmaStar=s*t+(1-s)*this.smoothed.sigmaStar,this.smoothed.bifurcationRisk=s*e+(1-s)*this.smoothed.bifurcationRisk,this.smoothed.sigmaR=s*i+(1-s)*this.smoothed.sigmaR)}_computePredictions(){if(this.buffers.sigmaStar.length>=2){const e=this.buffers.sigmaStar.slice(-3),i=this._linearTrend(e);this.prediction.expectedSigmaStar=Math.max(0,Math.min(1,e[e.length-1]+i*this.params.predictionHorizon))}else this.prediction.expectedSigmaStar=this.smoothed.sigmaStar;const t=3;this.prediction.expectedRisk=1-Math.tanh(t*this.prediction.expectedSigmaStar)}_linearTrend(t){if(t.length<2)return 0;const e=t.length,i=Array.from({length:e},(c,l)=>l),s=t,a=i.reduce((c,l)=>c+l,0),r=s.reduce((c,l)=>c+l,0),o=i.reduce((c,l,h)=>c+l*s[h],0),n=i.reduce((c,l)=>c+l*l,0);return(e*o-a*r)/(e*n-a*a)||0}_applyDecisionLogic(){const t=this._getRecentAverage("bifurcationRisk"),e=this._getRecentAverage("sigmaStar"),i=this._getRecentAverage("sigmaR"),s=this.prediction.expectedSigmaStar,a=this.prediction.expectedRisk,r=this._computePhiPenalty(),o=this.params.riskCrisisThreshold*r,n=this.params.riskNormalThreshold;let m=this.state.currentRegime,c=.5;const l=t>o&&i<this.params.sigmaRCrisisLimit||a>.8&&e<this.params.sigmaStarCrisisLimit;l&&(m="CRISIS",c=1-t*(1-e));const h=t<n&&e>this.params.sigmaStarRecovery||s>.92&&a<.25;return h&&(m="NORMAL",c=1-t*(1-e)),!l&&!h&&(m=this.state.currentRegime,c=this.state.regimeScore),{regimeState:m,regimeScore:Math.max(0,Math.min(1,c))}}_computePhiPenalty(){if(this.buffers.phiRatio.length===0)return 1;const t=1.618,e=this._getRecentAverage("phiRatio");return Math.abs(e-t)>this.params.phiToleranceWindow?1/this.params.phiViolationPenalty:1}_getRecentAverage(t){const e=this.buffers[t];if(e.length===0)return 0;const i=Math.min(this.params.hysteresisWindow,e.length),s=e.slice(-i);return s.reduce((a,r)=>a+r,0)/s.length}_updateState(t){const{regimeState:e,regimeScore:i}=t;e!==this.state.currentRegime?(this.state.previousRegime=this.state.currentRegime,this.state.currentRegime=e,this.state.transitionCount++,this.state.ticksSinceTransition=0,console.log(`ðŸŽ¯ Regime transition: ${this.state.previousRegime} â†’ ${e} (transition #${this.state.transitionCount})`)):this.state.ticksSinceTransition++,this.state.regimeScore=i}_computeConfidence(){const t=Math.min(1,this.state.ticksSinceTransition/10),e=this._getRecentAverage("bifurcationRisk");this._getRecentAverage("sigmaStar");let i=0;this.state.currentRegime==="CRISIS"?i=Math.max(0,e-this.params.riskNormalThreshold):i=Math.max(0,this.params.riskCrisisThreshold-e);const s=Math.min(1,i*2),a=this._computeVariance("bifurcationRisk"),r=1-Math.min(1,a*10),o=.4*t+.3*s+.3*r;return Math.max(0,Math.min(1,o))}_computeVariance(t){const e=this.buffers[t];if(e.length<2)return 0;const i=Math.min(this.params.hysteresisWindow,e.length),s=e.slice(-i),a=s.reduce((o,n)=>o+n,0)/s.length;return s.reduce((o,n)=>o+Math.pow(n-a,2),0)/s.length}getCurrentRegime(){return this.state.currentRegime}getDiagnostics(){return{state:this.state,smoothed:this.smoothed,prediction:this.prediction,bufferLengths:{sigmaStar:this.buffers.sigmaStar.length,bifurcationRisk:this.buffers.bifurcationRisk.length,sigmaR:this.buffers.sigmaR.length},averages:{sigmaStar:this._getRecentAverage("sigmaStar"),bifurcationRisk:this._getRecentAverage("bifurcationRisk"),sigmaR:this._getRecentAverage("sigmaR")}}}reset(){this.state={currentRegime:"NORMAL",previousRegime:"NORMAL",regimeScore:1,transitionCount:0,ticksSinceTransition:0},this.buffers={sigmaStar:[],sigmaR:[],bifurcationRisk:[],phiRatio:[]},this.smoothed={sigmaStar:null,bifurcationRisk:null,sigmaR:null},this.prediction={expectedSigmaStar:null,expectedRisk:null},console.log("ðŸŽ¯ RegimeClassifier reset")}}console.log("ðŸŽ¯ RegimeClassifier class ready");console.log("ðŸ”® forecastingEngine.js loaded");class Z{constructor(t,e={}){this.kalman=t,this.params={forecastHorizon:e.forecastHorizon??24,crisisThreshold:e.crisisThreshold??.7,alertThreshold:e.alertThreshold??.65,validationWindow:e.validationWindow??100,leadTimeMax:e.leadTimeMax??50,...e},this.forecast={sigmaStar:[],bifurcationRisk:[],crisisProbability:0,expectedLeadTime:0,confidence:0},this.alerts={active:!1,type:null,issuedAt:null,forecastedCrisisTime:null,message:""},this.validation={history:[],truePositives:0,falsePositives:0,trueNegatives:0,falseNegatives:0,leadTimes:[],lastCrisisActual:null,lastCrisisPredicted:null},this.replayBuffer={ticks:[],features:[],regimes:[],maxLength:1e3},console.log("ðŸ”® ForecastingEngine initialized"),console.log(`   Forecast horizon: ${this.params.forecastHorizon} ticks`),console.log(`   Crisis threshold: ${(this.params.crisisThreshold*100).toFixed(0)}%`)}generateForecast(t,e){const i=this.params.forecastHorizon,s=this.kalman.A,a=this.kalman.B;this.forecast.sigmaStar=[],this.forecast.bifurcationRisk=[];let r=t;for(let o=1;o<=i;o++){const n=Math.exp(-o/10),[m,c]=e,l=(a[0]*m+a[1]*c)*n;r=s*r+l,r=Math.max(0,Math.min(1,r)),this.forecast.sigmaStar.push(r);const u=1-Math.tanh(3*r);this.forecast.bifurcationRisk.push(u)}this._computeCrisisProbability(),this._computeExpectedLeadTime(),this.forecast.confidence=1-this.kalman.P,this._evaluateAlerts()}_computeCrisisProbability(){const t=this.forecast.bifurcationRisk;if(t.length===0){this.forecast.crisisProbability=0;return}const e=Math.max(...t),i=t.reduce((s,a)=>s+a,0)/t.length;this.forecast.crisisProbability=.7*e+.3*i}_computeExpectedLeadTime(){const t=this.forecast.bifurcationRisk,e=this.params.crisisThreshold,i=t.findIndex(s=>s>e);i===-1?this.forecast.expectedLeadTime=this.params.forecastHorizon:this.forecast.expectedLeadTime=i+1}_evaluateAlerts(){const t=this.forecast.crisisProbability,e=this.forecast.expectedLeadTime;if(t<this.params.alertThreshold*.8){this.alerts.active&&console.log("ðŸ”® Alert cleared - risk subsided"),this.alerts.active=!1,this.alerts.type=null;return}t>=this.params.crisisThreshold&&!this.alerts.active?(this.alerts.active=!0,this.alerts.type="CRISIS",this.alerts.issuedAt=Date.now(),this.alerts.forecastedCrisisTime=e,this.alerts.message=`CRISIS PREDICTED in ${e} ticks (${(t*100).toFixed(0)}% probability)`,console.log(`ðŸš¨ ${this.alerts.message}`)):t>=this.params.alertThreshold&&!this.alerts.active&&(this.alerts.active=!0,this.alerts.type="WARNING",this.alerts.issuedAt=Date.now(),this.alerts.forecastedCrisisTime=e,this.alerts.message=`Crisis WARNING - risk rising (${(t*100).toFixed(0)}% in ${e} ticks)`,console.log(`âš ï¸  ${this.alerts.message}`))}recordActual(t,e,i){const s=t==="CRISIS";if(this.replayBuffer.ticks.push(e),this.replayBuffer.features.push(i),this.replayBuffer.regimes.push(t),this.replayBuffer.ticks.length>this.replayBuffer.maxLength&&(this.replayBuffer.ticks.shift(),this.replayBuffer.features.shift(),this.replayBuffer.regimes.shift()),this.alerts.active&&s){const a=this.alerts.forecastedCrisisTime;this.validation.truePositives++,this.validation.leadTimes.push(a),this.validation.lastCrisisPredicted=Date.now(),this.validation.history.push({predicted:!0,actual:!0,leadTime:a,timestamp:Date.now(),type:"TP"}),console.log(`âœ… PREDICTION SUCCESS - Lead time: ${a} ticks`),this.alerts.active=!1}else if(this.alerts.active&&!s){const a=Date.now()-this.alerts.issuedAt,r=this.params.forecastHorizon*1e3;a>r&&(this.validation.falsePositives++,this.validation.history.push({predicted:!0,actual:!1,leadTime:null,timestamp:Date.now(),type:"FP"}),console.log("âŒ FALSE POSITIVE - Crisis did not materialize"),this.alerts.active=!1)}else!this.alerts.active&&s?(this.validation.falseNegatives++,this.validation.history.push({predicted:!1,actual:!0,leadTime:null,timestamp:Date.now(),type:"FN"}),console.log("âš ï¸  FALSE NEGATIVE - Missed crisis prediction")):this.validation.trueNegatives++;s&&this.validation.lastCrisisActual!==s&&(this.validation.lastCrisisActual=Date.now()),this.validation.history.length>this.params.validationWindow&&this.validation.history.shift()}getValidationMetrics(){const t=this.validation.truePositives,e=this.validation.falsePositives,i=this.validation.trueNegatives,s=this.validation.falseNegatives,a=t+e+i+s;if(a===0)return{precision:0,recall:0,accuracy:0,f1Score:0,avgLeadTime:0,leadTimeStdDev:0};const r=t+e>0?t/(t+e):0,o=t+s>0?t/(t+s):0,n=(t+i)/a,m=r+o>0?2*(r*o)/(r+o):0,c=this.validation.leadTimes,l=c.length>0?c.reduce((g,p)=>g+p,0)/c.length:0,h=c.length>1?c.reduce((g,p)=>g+Math.pow(p-l,2),0)/c.length:0,u=Math.sqrt(h);return{precision:r,recall:o,accuracy:n,f1Score:m,avgLeadTime:l,leadTimeStdDev:u,truePositives:t,falsePositives:e,trueNegatives:i,falseNegatives:s,totalPredictions:a}}getForecast(){return{...this.forecast,alert:this.alerts.active?this.alerts:null}}getAlert(){return this.alerts.active?this.alerts:null}runBacktest(t=0,e=null){if(this.replayBuffer.ticks.length===0)return console.warn("ðŸ”® No replay data available for backtest"),null;const i=e||this.replayBuffer.ticks.length,s=[];console.log(`ðŸ”® Running backtest on ${i-t} samples...`);for(let h=t;h<i;h++){const u=this.replayBuffer.features[h];this.replayBuffer.regimes[h];const g=u.features.resolution.sigma_star,p=[u.features.transformation.flux,u.features.resolution.sigma_R];this.generateForecast(g,p);let k=!1,R=null;for(let f=1;f<=this.params.forecastHorizon&&h+f<i;f++)if(this.replayBuffer.regimes[h+f]==="CRISIS"){k=!0,R=f;break}const y=this.forecast.crisisProbability>this.params.crisisThreshold;s.push({index:h,predicted:y,actual:k,predictedProb:this.forecast.crisisProbability,actualLeadTime:R,predictedLeadTime:this.forecast.expectedLeadTime})}const a=s.filter(h=>h.predicted&&h.actual).length,r=s.filter(h=>h.predicted&&!h.actual).length,o=s.filter(h=>!h.predicted&&!h.actual).length,n=s.filter(h=>!h.predicted&&h.actual).length,m=a+r>0?a/(a+r):0,c=a+n>0?a/(a+n):0,l=(a+o)/s.length;return console.log("ðŸ”® Backtest complete:"),console.log(`   Precision: ${(m*100).toFixed(1)}%`),console.log(`   Recall: ${(c*100).toFixed(1)}%`),console.log(`   Accuracy: ${(l*100).toFixed(1)}%`),{results:s,metrics:{precision:m,recall:c,accuracy:l,tp:a,fp:r,tn:o,fn:n}}}resetValidation(){this.validation={history:[],truePositives:0,falsePositives:0,trueNegatives:0,falseNegatives:0,leadTimes:[],lastCrisisActual:null,lastCrisisPredicted:null},console.log("ðŸ”® Validation metrics reset")}exportReplayBuffer(){return{ticks:[...this.replayBuffer.ticks],features:[...this.replayBuffer.features],regimes:[...this.replayBuffer.regimes]}}}console.log("ðŸ”® ForecastingEngine class ready");console.log("â‚¿ coingeckoRestSource.js loaded");class F{constructor(t={}){this.config={symbol:t.symbol||"bitcoin",pollInterval:t.pollInterval||1e4,maxRetries:t.maxRetries||5,retryDelay:t.retryDelay||15e3,...t},this.listeners=[],this.isRunning=!1,this.pollTimer=null,this.retryCount=0,this.rateLimitBackoff=0,this.state={lastPrice:null,lastUpdate:Date.now(),updateCount:0,connected:!1},console.log(`â‚¿ CoinGeckoRestSource initialized for ${this.config.symbol}`)}start(){if(this.isRunning){console.warn("â‚¿ CoinGecko REST already running");return}this.isRunning=!0,this.state.connected=!0,console.log("â‚¿ Starting CoinGecko REST polling"),this._poll()}stop(){console.log("â‚¿ Stopping CoinGecko REST polling"),this.isRunning=!1,this.state.connected=!1,this.pollTimer&&(clearTimeout(this.pollTimer),this.pollTimer=null)}onTick(t){this.listeners.push(t)}async _poll(){if(this.isRunning){try{const t=`https://api.coingecko.com/api/v3/simple/price?ids=${this.config.symbol}&vs_currencies=usd&include_24hr_vol=true`,e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);const i=await e.json();if(i&&i[this.config.symbol]&&i[this.config.symbol].usd){const s=parseFloat(i[this.config.symbol].usd),a=i[this.config.symbol].usd_24h_vol||0;this.state.lastPrice=s,this.state.lastUpdate=Date.now(),this.state.updateCount++;const r=new T("BTC",s,a,Date.now());this.listeners.forEach(o=>o(r)),this.retryCount=0,this.rateLimitBackoff=0,this.state.updateCount===1&&console.log(`â‚¿ CoinGecko REST connected - BTC price: $${s.toLocaleString("en-US",{minimumFractionDigits:2,maximumFractionDigits:2})}`)}}catch(t){if(t.message.includes("429")){this.rateLimitBackoff=Math.min(this.rateLimitBackoff+1e4,6e4),console.warn(`â‚¿ CoinGecko rate limit hit - backing off for ${this.rateLimitBackoff/1e3}s`),this.isRunning&&(this.pollTimer=setTimeout(()=>{this._poll()},this.config.pollInterval+this.rateLimitBackoff));return}if(console.error("â‚¿ CoinGecko REST error:",t.message),this.retryCount++,this.retryCount>=this.config.maxRetries){console.error(`â‚¿ Max retries (${this.config.maxRetries}) reached. Stopping.`),console.error("â‚¿ Your network may be blocking cryptocurrency API access."),console.error("â‚¿ Try using a VPN or different network if you need live data."),this.stop();return}console.log(`â‚¿ Retry ${this.retryCount}/${this.config.maxRetries} in ${this.config.retryDelay}ms`)}if(this.isRunning){const t=this.config.pollInterval+this.rateLimitBackoff;this.pollTimer=setTimeout(()=>{this._poll()},t)}}}getState(){return{symbol:this.config.symbol,connected:this.state.connected,price:this.state.lastPrice,updateCount:this.state.updateCount,retryCount:this.retryCount}}}console.log("â‚¿ CoinGeckoRestSource class ready");console.log("â‚¿ coincapSource.js loaded");class tt{constructor(t={}){this.config={symbol:t.symbol||"bitcoin",pollInterval:t.pollInterval||5e3,maxRetries:t.maxRetries||5,retryDelay:t.retryDelay||1e4,...t},this.listeners=[],this.isRunning=!1,this.pollTimer=null,this.retryCount=0,this.rateLimitBackoff=0,this.state={lastPrice:null,lastUpdate:Date.now(),updateCount:0,connected:!1},console.log(`â‚¿ CoinCapSource initialized for ${this.config.symbol}`)}start(){if(this.isRunning){console.warn("â‚¿ CoinCap already running");return}this.isRunning=!0,this.state.connected=!0,console.log("â‚¿ Starting CoinCap polling"),this._poll()}stop(){console.log("â‚¿ Stopping CoinCap polling"),this.isRunning=!1,this.state.connected=!1,this.pollTimer&&(clearTimeout(this.pollTimer),this.pollTimer=null)}onTick(t){this.listeners.push(t)}async _poll(){if(this.isRunning){try{const t=`https://api.coincap.io/v2/assets/${this.config.symbol}`,e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);const i=await e.json();if(i&&i.data&&i.data.priceUsd){const s=parseFloat(i.data.priceUsd),a=parseFloat(i.data.volumeUsd24Hr||0);this.state.lastPrice=s,this.state.lastUpdate=Date.now(),this.state.updateCount++;const r=new T("BTC",s,a,Date.now());this.listeners.forEach(o=>o(r)),this.retryCount=0,this.rateLimitBackoff=0,this.state.updateCount===1&&console.log(`â‚¿ CoinCap connected - BTC price: $${s.toLocaleString("en-US",{minimumFractionDigits:2,maximumFractionDigits:2})}`)}}catch(t){if(t.message.includes("429")){this.rateLimitBackoff=Math.min(this.rateLimitBackoff+5e3,3e4),console.warn(`â‚¿ CoinCap rate limit hit - backing off for ${this.rateLimitBackoff/1e3}s`),this.isRunning&&(this.pollTimer=setTimeout(()=>{this._poll()},this.config.pollInterval+this.rateLimitBackoff));return}if(console.error("â‚¿ CoinCap error:",t.message),this.retryCount++,this.retryCount>=this.config.maxRetries){console.error(`â‚¿ Max retries (${this.config.maxRetries}) reached. Stopping.`),this.stop();return}console.log(`â‚¿ Retry ${this.retryCount}/${this.config.maxRetries} in ${this.config.retryDelay}ms`)}if(this.isRunning){const t=this.config.pollInterval+this.rateLimitBackoff;this.pollTimer=setTimeout(()=>{this._poll()},t)}}}getState(){return{symbol:this.config.symbol,connected:this.state.connected,price:this.state.lastPrice,updateCount:this.state.updateCount,retryCount:this.retryCount}}}console.log("â‚¿ CoinCapSource class ready");console.log("â‚¿ binanceSource.js loaded");class et{constructor(t={}){this.config={symbol:t.symbol||"BTCUSDT",pollInterval:t.pollInterval||3e3,maxRetries:t.maxRetries||5,retryDelay:t.retryDelay||1e4,...t},this.listeners=[],this.isRunning=!1,this.pollTimer=null,this.retryCount=0,this.rateLimitBackoff=0,this.state={lastPrice:null,lastUpdate:Date.now(),updateCount:0,connected:!1},console.log(`â‚¿ BinanceSource initialized for ${this.config.symbol}`)}start(){if(this.isRunning){console.warn("â‚¿ Binance already running");return}this.isRunning=!0,this.state.connected=!0,console.log("â‚¿ Starting Binance polling"),this._poll()}stop(){console.log("â‚¿ Stopping Binance polling"),this.isRunning=!1,this.state.connected=!1,this.pollTimer&&(clearTimeout(this.pollTimer),this.pollTimer=null)}onTick(t){this.listeners.push(t)}async _poll(){if(this.isRunning){try{const t=`https://api.binance.com/api/v3/ticker/24hr?symbol=${this.config.symbol}`,e=await fetch(t,{method:"GET",headers:{Accept:"application/json"}});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);const i=await e.json();if(i&&i.lastPrice){const s=parseFloat(i.lastPrice),a=parseFloat(i.quoteVolume||0);this.state.lastPrice=s,this.state.lastUpdate=Date.now(),this.state.updateCount++;const r=new T("BTC",s,a,Date.now());this.listeners.forEach(o=>o(r)),this.retryCount=0,this.rateLimitBackoff=0,this.state.updateCount===1&&console.log(`â‚¿ Binance connected - BTC price: $${s.toLocaleString("en-US",{minimumFractionDigits:2,maximumFractionDigits:2})}`)}}catch(t){if(t.message.includes("429")||t.message.includes("418")){this.rateLimitBackoff=Math.min(this.rateLimitBackoff+5e3,3e4),console.warn(`â‚¿ Binance rate limit hit - backing off for ${this.rateLimitBackoff/1e3}s`),this.isRunning&&(this.pollTimer=setTimeout(()=>{this._poll()},this.config.pollInterval+this.rateLimitBackoff));return}if(console.error("â‚¿ Binance error:",t.message),this.retryCount++,this.retryCount>=this.config.maxRetries){console.error(`â‚¿ Max retries (${this.config.maxRetries}) reached. Stopping.`),this.stop();return}console.log(`â‚¿ Retry ${this.retryCount}/${this.config.maxRetries} in ${this.config.retryDelay}ms`)}if(this.isRunning){const t=this.config.pollInterval+this.rateLimitBackoff;this.pollTimer=setTimeout(()=>{this._poll()},t)}}}getState(){return{symbol:this.config.symbol,connected:this.state.connected,price:this.state.lastPrice,updateCount:this.state.updateCount,retryCount:this.retryCount}}}console.log("â‚¿ BinanceSource class ready");console.log("â‚¿ dataSourceManager.js loaded");class it{constructor(){this.sources={coingecko:{name:"CoinGecko",description:"CoinGecko API (10s, moderate limits)",factory:()=>new F({symbol:"bitcoin"}),instance:null},coincap:{name:"CoinCap",description:"CoinCap API (5s, generous limits)",factory:()=>new tt({symbol:"bitcoin"}),instance:null},binance:{name:"Binance",description:"Binance Public API (3s, very generous)",factory:()=>new et({symbol:"BTCUSDT"}),instance:null},mock:{name:"Mock Data",description:"Synthetic Bitcoin data (1s, unlimited)",factory:()=>new _({symbol:"BTC"}),instance:null}},this.currentSourceKey=this._loadPreference(),this.activeSource=null,this.listeners=[],console.log(`â‚¿ DataSourceManager initialized - Default source: ${this.currentSourceKey}`)}getAvailableSources(){return Object.keys(this.sources).map(t=>({key:t,name:this.sources[t].name,description:this.sources[t].description}))}getCurrentSource(){return this.currentSourceKey}switchSource(t){return this.sources[t]?(console.log(`â‚¿ Switching data source to: ${this.sources[t].name}`),this.activeSource&&(this.activeSource.stop(),this.activeSource=null),this.sources[t].instance||(this.sources[t].instance=this.sources[t].factory(),this.sources[t].instance.onTick(e=>{this._emitTick(e)})),this.activeSource=this.sources[t].instance,this.currentSourceKey=t,this._savePreference(t),this.activeSource.start(),console.log(`âœ“ Data source switched to: ${this.sources[t].name}`),!0):(console.error(`â‚¿ Unknown data source: ${t}`),!1)}start(){this.activeSource?this.activeSource&&this.activeSource.start():this.switchSource(this.currentSourceKey)}stop(){this.activeSource&&this.activeSource.stop()}onTick(t){this.listeners.push(t)}getState(){if(!this.activeSource)return{source:this.currentSourceKey,connected:!1,price:null,updateCount:0};const t=this.activeSource.getState();return{source:this.currentSourceKey,sourceName:this.sources[this.currentSourceKey].name,...t}}_emitTick(t){this.listeners.forEach(e=>{try{e(t)}catch(i){console.error("â‚¿ Error in tick listener:",i)}})}_loadPreference(){try{const t=localStorage.getItem("mmpa_data_source");if(t&&this.sources[t])return console.log(`â‚¿ Loaded user preference: ${t}`),t}catch(t){console.warn("â‚¿ Could not load data source preference:",t)}return"coincap"}_savePreference(t){try{localStorage.setItem("mmpa_data_source",t),console.log(`â‚¿ Saved user preference: ${t}`)}catch(e){console.warn("â‚¿ Could not save data source preference:",e)}}}console.log("â‚¿ DataSourceManager class ready");console.log("ðŸ’¹ financialDataPipeline.js loaded");class T{constructor(t,e,i,s=null){this.symbol=t,this.price=e,this.volume=i,this.timestamp=s||Date.now()}}const C={SPY:{initialPrice:590,baseVolatility:.015,crisisVolatility:.05,trendDrift:1e-4},QQQ:{initialPrice:510,baseVolatility:.02,crisisVolatility:.07,trendDrift:15e-5},BTC:{initialPrice:11e4,baseVolatility:.04,crisisVolatility:.15,trendDrift:2e-4},TSLA:{initialPrice:350,baseVolatility:.035,crisisVolatility:.1,trendDrift:5e-5}};class _{constructor(t={}){const e=t.symbol||"SPY",i=C[e]||C.SPY;this.config={symbol:e,initialPrice:i.initialPrice,baseVolatility:i.baseVolatility,trendDrift:i.trendDrift,crisisVolatility:i.crisisVolatility,regimeChangeProb:.02,updateInterval:1e3,...t},this.state={currentPrice:this.config.initialPrice,currentVolume:1e8,tickCount:0,inCrisis:!1,crisisCountdown:0},this.intervalId=null,this.listeners=[]}start(){if(this.intervalId){console.warn("ðŸ’¹ Mock generator already running");return}console.log(`ðŸ’¹ Starting mock data generator for ${this.config.symbol}`),this.intervalId=setInterval(()=>{this._generateTick()},this.config.updateInterval)}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=null,console.log("ðŸ’¹ Mock data generator stopped"))}onTick(t){this.listeners.push(t)}_generateTick(){this.state.tickCount++,Math.random()<this.config.regimeChangeProb&&(this.state.inCrisis=!this.state.inCrisis,this.state.inCrisis?(this.state.crisisCountdown=20+Math.floor(Math.random()*30),console.log(`ðŸ’¹ âš ï¸ CRISIS MODE ACTIVATED (${this.state.crisisCountdown} ticks)`)):console.log("ðŸ’¹ âœ… Crisis mode ended, returning to normal")),this.state.inCrisis&&this.state.crisisCountdown>0&&(this.state.crisisCountdown--,this.state.crisisCountdown===0&&(this.state.inCrisis=!1));const t=this.state.inCrisis?this.config.crisisVolatility:this.config.baseVolatility,e=this.state.inCrisis?-.001:this.config.trendDrift,i=(Math.random()-.5)*2*t,s=e+i;this.state.currentPrice=this.state.currentPrice*(1+s);const a=1e8,r=1+Math.abs(i)*10;this.state.currentVolume=a*r*(.8+Math.random()*.4);const o=new T(this.config.symbol,this.state.currentPrice,this.state.currentVolume,Date.now());return this.listeners.forEach(n=>n(o)),o}getState(){return{symbol:this.config.symbol,price:this.state.currentPrice,volume:this.state.currentVolume,tickCount:this.state.tickCount,inCrisis:this.state.inCrisis,crisisCountdown:this.state.crisisCountdown}}}class ot{constructor(t={}){this.config={source:"mock",symbol:"SPY",autoStart:!1,dataSourceKey:null,...t},this.extractor=new X(t.extractorParams||{}),this.regimeClassifier=new J(t.regimeParams||{}),this.forecastingEngine=null,this.dataSource=null,this.dataSourceManager=null,this.useManager=!1,this.listeners={tick:[],features:[],error:[]},this._initDataSource(),this.config.autoStart&&this.start()}_initDataSource(){if(this.config.source==="managed"||this.config.dataSourceKey){console.log("ðŸ’¹ Using DataSourceManager for multi-source support"),this.useManager=!0,this.dataSourceManager=new it,this.config.dataSourceKey&&this.dataSourceManager.switchSource(this.config.dataSourceKey),this.dataSourceManager.onTick(t=>this._handleTick(t));return}switch(this.config.source){case"mock":this.dataSource=new _({symbol:this.config.symbol,updateInterval:this.config.updateInterval||1e3});break;case"websocket":this.config.symbol==="BTC"?(this.dataSource=new F({symbol:"bitcoin",pollInterval:this.config.updateInterval||1e4}),console.log("â‚¿ Using CoinGecko API for live Bitcoin data (10s updates)")):(console.warn(`ðŸ’¹ Live data source not available for ${this.config.symbol}, using mock data`),this.dataSource=new _({symbol:this.config.symbol}));break;case"rest":console.warn("ðŸ’¹ REST source not yet implemented, falling back to mock"),this.dataSource=new _({symbol:this.config.symbol});break;default:console.error(`ðŸ’¹ Unknown source: ${this.config.source}, using mock`),this.dataSource=new _({symbol:this.config.symbol})}this.dataSource.onTick(t=>this._handleTick(t))}_handleTick(t){this.listeners.tick.forEach(s=>s(t));const e=this.extractor.update(t.price,t.volume,t.timestamp),i=this.regimeClassifier.calculateRegimeState({sigmaStar:e.features.resolution.sigma_star,sigmaR:e.features.resolution.sigma_R,bifurcationRisk:e.features.resolution.bifurcation_risk,phiRatio:e.features.resolution.phi_ratio});if(e.regimeState=i,!this.forecastingEngine&&this.extractor.kalmanFilter&&(this.forecastingEngine=new Z(this.extractor.kalmanFilter,this.config.forecastParams||{}),console.log("ðŸ”® ForecastingEngine initialized in pipeline")),this.forecastingEngine){const s=e.features.resolution.sigma_star,a=e.features.transformation.flux,r=e.features.resolution.sigma_R,o=[a,r];this.forecastingEngine.generateForecast(s,o),this.forecastingEngine.recordActual(i.regimeState,t.timestamp,e),e.forecast=this.forecastingEngine.getForecast(),e.validationMetrics=this.forecastingEngine.getValidationMetrics()}this.dataSource&&this.dataSource.state&&(this.dataSource.state.inCrisis=i.regimeState==="CRISIS",this.dataSource.state.inCrisis||(this.dataSource.state.crisisCountdown=0)),this.listeners.features.forEach(s=>s(e,t))}start(){console.log(`ðŸ’¹ Starting financial data pipeline (source: ${this.config.source})`),this.useManager&&this.dataSourceManager?this.dataSourceManager.start():this.dataSource&&this.dataSource.start&&this.dataSource.start()}stop(){console.log("ðŸ’¹ Stopping financial data pipeline"),this.useManager&&this.dataSourceManager?this.dataSourceManager.stop():this.dataSource&&this.dataSource.stop&&this.dataSource.stop()}switchDataSource(t){return!this.useManager||!this.dataSourceManager?(console.warn("ðŸ’¹ Data source switching requires DataSourceManager. Reinitialize with source='managed'"),!1):this.dataSourceManager.switchSource(t)}getAvailableDataSources(){return!this.useManager||!this.dataSourceManager?[]:this.dataSourceManager.getAvailableSources()}getCurrentDataSource(){return this.useManager&&this.dataSourceManager?this.dataSourceManager.getState():this.dataSource&&this.dataSource.getState?{source:this.config.source,...this.dataSource.getState()}:{source:this.config.source,connected:!1}}onTick(t){this.listeners.tick.push(t)}onFeatures(t){this.listeners.features.push(t)}onError(t){this.listeners.error.push(t)}getState(){var t,e;return{source:this.config.source,symbol:this.config.symbol,dataSource:((e=(t=this.dataSource)==null?void 0:t.getState)==null?void 0:e.call(t))||null,extractor:this.extractor.getStateSummary()}}setSymbol(t){if(this.config.symbol=t,this.config.source==="mock"){const e=this.dataSource.intervalId!==null;this.stop(),this.dataSource=new _({symbol:t,updateInterval:this.config.updateInterval||1e3});const i=C[t]||C.SPY;console.log(`ðŸ’¹ Symbol changed to ${t}`),console.log(`   Initial Price: $${i.initialPrice.toLocaleString()}`),console.log(`   Base Volatility: ${(i.baseVolatility*100).toFixed(1)}%`),console.log(`   Crisis Volatility: ${(i.crisisVolatility*100).toFixed(1)}%`),this.dataSource.onTick(s=>this._handleTick(s)),this.extractor.reset(),console.log("   Feature extractor reset for new symbol"),e&&this.start()}}resetExtractor(){this.extractor.reset(),console.log("ðŸ’¹ Feature extractor state reset")}}console.log("ðŸ’¹ Financial Data Pipeline module ready");export{ot as FinancialDataPipeline,T as MarketTick,_ as MockDataGenerator};
//# sourceMappingURL=financialDataPipeline-CUKVih2x.js.map
