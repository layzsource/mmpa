// src/destinations.js
// VCN Phase 1: Destination System
// Data structures for signal-space destinations and navigation targets

import * as THREE from 'three';

console.log("ðŸ§­ destinations.js loaded");

/**
 * SignalDestination â€” A navigable point in signal-space
 * Represents morphic attractors, resonance nodes, parameter portals, etc.
 */
export class SignalDestination {
  constructor(type, position, signalWeight = 0.5, category = 'unknown') {
    this.id = `dest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.type = type; // 'morphic_attractor', 'resonance_node', 'spectral_storm', etc.
    this.position = position; // THREE.Vector3
    this.radius = 10.0;
    this.signalWeight = signalWeight; // 0.0-1.0
    this.category = category; // 'geometry', 'mandala', 'streams', 'particles', 'telemetry', 'parameters', 'sprites', 'controls'
    this.color = this.getColorForCategory(category);
    this.active = true;
    this.createdAt = Date.now();
    this.autoGenerated = false; // Flag for field-generated destinations
    this.turbulence = false; // Flag for turbulent zones
  }

  /**
   * Get color based on event category (Conflat-6 face colors)
   */
  getColorForCategory(category) {
    const colors = {
      'geometry': '#00ffff',      // North (+Z) - Cyan - Morph geometry
      'mandala': '#ff00ff',        // South (-Z) - Magenta - Mandala rings
      'streams': '#ff0000',        // East (+X) - Red - Emoji streams
      'particles': '#00ff00',      // West (-X) - Green - Particle fields
      'telemetry': '#0000ff',      // Up (+Y) - Blue - Audio telemetry
      'parameters': '#ffff00',     // Down (-Y) - Yellow - Parameter space
      'sprites': '#ff6600',        // Orange - Sprite system
      'controls': '#9900ff',       // Purple - Control events
      'vessel': '#00ffff'          // Cyan - Vessel beacons
    };
    return colors[category] || '#ffffff';
  }

  /**
   * Update signal weight based on current audio state
   */
  updateFromTelemetry(audioData) {
    const { bass, mid, treble } = audioData;

    // Different destination types respond to different frequency bands
    switch (this.type) {
      case 'morphic_attractor':
      case 'resonance_node':
        this.signalWeight = mid * 0.7 + bass * 0.3;
        break;

      case 'spectral_storm':
      case 'moirÃ©_storm':
        this.signalWeight = treble * 0.6 + (bass + mid + treble) / 3 * 0.4;
        break;

      case 'chladni_node':
        this.signalWeight = bass * 0.5 + mid * 0.5;
        break;

      case 'pitch_beacon':
        this.signalWeight = mid * 0.8 + treble * 0.2;
        break;

      default:
        this.signalWeight = (bass + mid + treble) / 3;
    }

    // Clamp to valid range
    this.signalWeight = Math.max(0, Math.min(1, this.signalWeight));
  }

  /**
   * Get distance from a position (usually camera)
   */
  getDistanceFrom(position) {
    return this.position.distanceTo(position);
  }

  /**
   * Get bearing from camera (-1 = behind, 0 = perpendicular, +1 = ahead)
   */
  getBearingFrom(camera) {
    const vectorToTarget = this.position.clone().sub(camera.position).normalize();
    const cameraForward = camera.getWorldDirection(new THREE.Vector3());
    return vectorToTarget.dot(cameraForward);
  }

  /**
   * Get signal strength with distance decay (dowsing rod "hot/cold")
   */
  getSignalStrength(distance) {
    return this.signalWeight / (1 + distance * 0.05);
  }

  /**
   * Get apparent size (angular size from viewer position)
   */
  getApparentSize(distance) {
    return this.radius / Math.max(distance, 0.1);
  }

  /**
   * Check if destination is within angular cone from camera
   * @param {THREE.Camera} camera
   * @param {number} coneAngle - Half-angle in radians (e.g., Math.PI/3 for 60Â° cone)
   */
  isInViewCone(camera, coneAngle = Math.PI / 3) {
    const bearing = this.getBearingFrom(camera);
    const threshold = Math.cos(coneAngle);
    return bearing > threshold;
  }

  /**
   * Get pulse rate based on distance (closer = faster pulse)
   * Returns milliseconds per pulse cycle
   */
  getPulseRate(distance) {
    return 1000 / (1 + distance * 0.05); // 1000ms at far, faster when close
  }
}

/**
 * DestinationManager â€” Tracks and manages all active destinations
 */
export class DestinationManager {
  constructor() {
    this.destinations = [];
    this.maxDestinations = 80; // Allow up to 80 simultaneous destinations
    this.categoryCounts = {};
  }

  /**
   * Add a destination to the manager
   */
  add(destination) {
    this.destinations.push(destination);

    // Track category count
    this.categoryCounts[destination.category] = (this.categoryCounts[destination.category] || 0) + 1;

    // Prune oldest if over limit
    if (this.destinations.length > this.maxDestinations) {
      const removed = this.destinations.shift();
      this.categoryCounts[removed.category]--;
      console.log(`ðŸ§­ Destination limit reached, pruned oldest: ${removed.type}`);
    }
  }

  /**
   * Remove destination by ID
   */
  remove(id) {
    const index = this.destinations.findIndex(d => d.id === id);
    if (index >= 0) {
      const removed = this.destinations.splice(index, 1)[0];
      this.categoryCounts[removed.category]--;
      return removed;
    }
    return null;
  }

  /**
   * Remove all destinations matching a filter
   */
  removeWhere(filterFn) {
    const toRemove = this.destinations.filter(filterFn);
    this.destinations = this.destinations.filter(d => !filterFn(d));

    toRemove.forEach(d => {
      this.categoryCounts[d.category]--;
    });

    return toRemove.length;
  }

  /**
   * Update all destinations with current audio data
   */
  update(audioData) {
    this.destinations.forEach(dest => {
      if (dest.active) {
        dest.updateFromTelemetry(audioData);
      }
    });
  }

  /**
   * Get nearest destination to a position
   */
  getNearestTo(position, filterFn = null) {
    let nearest = null;
    let minDist = Infinity;

    for (const dest of this.destinations) {
      if (!dest.active) continue;
      if (filterFn && !filterFn(dest)) continue;

      const dist = dest.getDistanceFrom(position);
      if (dist < minDist) {
        minDist = dist;
        nearest = dest;
      }
    }

    // Add distance property without losing methods
    if (nearest) {
      nearest.distance = minDist;
    }

    return nearest;
  }

  /**
   * Get nearest destination by category
   */
  getNearestByCategory(position, category) {
    return this.getNearestTo(position, d => d.category === category);
  }

  /**
   * Get all destinations within radius of position
   */
  getWithinRadius(position, radius) {
    return this.destinations
      .filter(d => d.active && d.getDistanceFrom(position) <= radius)
      .map(d => ({ ...d, distance: d.getDistanceFrom(position) }))
      .sort((a, b) => a.distance - b.distance);
  }

  /**
   * Get all destinations in view cone of camera
   */
  getInViewCone(camera, coneAngle = Math.PI / 3) {
    return this.destinations
      .filter(d => d.active && d.isInViewCone(camera, coneAngle))
      .map(d => ({ ...d, distance: d.getDistanceFrom(camera.position) }))
      .sort((a, b) => a.distance - b.distance);
  }

  /**
   * Get all active destinations
   */
  getAll() {
    return this.destinations.filter(d => d.active);
  }

  /**
   * Get destinations by category
   */
  getByCategory(category) {
    return this.destinations.filter(d => d.active && d.category === category);
  }

  /**
   * Get summary statistics
   */
  getStats() {
    const active = this.destinations.filter(d => d.active).length;
    const autoGenerated = this.destinations.filter(d => d.autoGenerated).length;

    return {
      total: this.destinations.length,
      active,
      autoGenerated,
      manual: active - autoGenerated,
      byCategory: { ...this.categoryCounts }
    };
  }

  /**
   * Clear all destinations (optionally keep manual ones)
   */
  clear(keepManual = false) {
    if (keepManual) {
      const removed = this.removeWhere(d => d.autoGenerated);
      console.log(`ðŸ§­ Cleared ${removed} auto-generated destinations`);
    } else {
      const count = this.destinations.length;
      this.destinations = [];
      this.categoryCounts = {};
      console.log(`ðŸ§­ Cleared all ${count} destinations`);
    }
  }

  /**
   * Prune old destinations based on age (milliseconds)
   */
  pruneOld(maxAge = 30000) {
    const now = Date.now();
    const removed = this.removeWhere(d => (now - d.createdAt) > maxAge);
    if (removed > 0) {
      console.log(`ðŸ§­ Pruned ${removed} destinations older than ${maxAge}ms`);
    }
  }
}

console.log("ðŸ§­ Destination system ready");
