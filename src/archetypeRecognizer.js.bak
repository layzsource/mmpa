console.log("üîç archetypeRecognizer.js loaded");

/**
 * MMPA Archetype Recognizer (œÜ-Based Implementation)
 *
 * Analyzes the current MMPA feature state to identify which archetype
 * the system is embodying using the Golden Ratio (œÜ) as the coherence threshold.
 *
 * Based on Dan Winter's Phase Conjugation theory, œÜ (1.618...) represents
 * the universal non-arbitrary standard for system coherence.
 *
 * Archetypes:
 * - PERFECT_FIFTH: The Ringing Bell (coherent, stable, harmonious) - stability ‚â• œÜ
 * - WOLF_FIFTH: The Cracked Bell (chaotic, imploding, crisis) - active but stability < œÜ
 * - NEUTRAL_STATE: The Aether (resting, sparse, quiet) - flux < activity floor
 */

import { GLOBAL_CONSTANTS } from './state.js';
import { isSynthMode, getSynthArchetype } from './synthPitchMapper.js';

// ============================================================================
// ARCHETYPE DEFINITIONS
// ============================================================================

// ANLG-Based Archetype System (œÄ/œÜ Ratio Classification)
export const ARCHETYPES = {
  PURE_HARMONY: 'PURE_HARMONY',      // œÜ/œÄ > 3.0 (Perfect Fifth, sustained consonance)
  HIGH_HARMONY: 'HIGH_HARMONY',      // œÜ/œÄ 1.5-3.0 (Consonant but active)
  BALANCED: 'BALANCED',              // œÜ/œÄ 0.8-1.5 (Moderate tension/resolution)
  HIGH_CHAOS: 'HIGH_CHAOS',          // œÜ/œÄ 0.3-0.8 (Dissonant, turbulent)
  PURE_CHAOS: 'PURE_CHAOS',          // œÜ/œÄ < 0.3 (Wolf Fifth, crisis)
  NEUTRAL_STATE: 'NEUTRAL_STATE'     // Silence (no audible signal)
};

// Legacy archetype names (for backward compatibility)
export const LEGACY_ARCHETYPES = {
  PERFECT_FIFTH: 'PURE_HARMONY',
  WOLF_FIFTH: 'PURE_CHAOS',
  NEUTRAL_STATE: 'NEUTRAL_STATE'
};

// ============================================================================
// CONFIGURATION
// ============================================================================

const PHI_THRESHOLD = GLOBAL_CONSTANTS.GOLDEN_RATIO_PHI;  // 1.618... - The coherence threshold
const ACTIVITY_FLOOR = GLOBAL_CONSTANTS.ACTIVITY_FLOOR;    // 0.5 - Minimum flux for active evaluation

// Recognition configuration
const RECOGNITION_CONFIG = {
  HISTORY_LENGTH: 60,             // Keep last 60 recognitions (1 second at 60fps)
  TRANSITION_COOLDOWN: 500,       // Milliseconds before allowing another transition

  // ANLG Layer: œÄ/œÜ Ratio Thresholds (CALIBRATION PARAMETERS)
  // These thresholds define the archetypal boundaries - adjust during empirical testing
  PURE_HARMONY_THRESHOLD: 3.0,   // œÜ/œÄ > 3.0 ‚Üí PURE_HARMONY
  HIGH_HARMONY_THRESHOLD: 1.5,   // œÜ/œÄ 1.5-3.0 ‚Üí HIGH_HARMONY
  BALANCED_UPPER: 1.5,            // œÜ/œÄ 0.8-1.5 ‚Üí BALANCED
  BALANCED_LOWER: 0.8,            //
  HIGH_CHAOS_THRESHOLD: 0.3,     // œÜ/œÄ 0.3-0.8 ‚Üí HIGH_CHAOS
                                  // œÜ/œÄ < 0.3 ‚Üí PURE_CHAOS

  // œÄ and œÜ Calibration Scales (adjust to match musical reality)
  // Goal: C Major chord ‚Üí œÜ ‚âà 0.8-0.9, œÄ ‚âà 0.1-0.2 (ratio ‚âà 4.0-9.0)
  // Goal: Dissonant cluster ‚Üí œÄ ‚âà 0.8-0.9, œÜ ‚âà 0.1-0.2 (ratio ‚âà 0.1-0.25)
  PI_SCALE: 1.0,                  // Multiplier for chaos component
  PHI_SCALE: 1.0,                 // Multiplier for harmony component

  // Legacy calibration factors (for backward compatibility)
  STABILITY_SCALE: 2.3,           // Calibrated to reach œÜ threshold with typical audio levels
  FLUX_NORMALIZATION: 1.0,        // Normalization factor for flux metric

  // Hysteresis margins (prevent flip-flopping between states)
  HYSTERESIS_PERCENT: 0.05,       // 5% margin for threshold crossings

  // Silence detection
  SILENCE_THRESHOLD: 0.01         // RMS amplitude below this = silence
};

// ============================================================================
// RECOGNITION STATE
// ============================================================================

let recognitionState = {
  currentArchetype: ARCHETYPES.NEUTRAL_STATE,
  previousArchetype: null,
  confidence: 0,
  lastStabilityMetric: 0,
  lastFluxMetric: 0,
  lastPi: 0,           // ANLG Layer: Chaos score
  lastPhi: 0,          // ANLG Layer: Harmony score
  lastPhiOverPi: 0,    // ANLG Layer: œÜ/œÄ ratio
  transitionInProgress: false,
  lastTransitionTime: 0,
  history: [],
  callbacks: {
    onArchetypeChange: [],
    onPureHarmonyEnter: [],
    onHighHarmonyEnter: [],
    onBalancedEnter: [],
    onHighChaosEnter: [],
    onPureChaosEnter: [],
    onNeutralStateEnter: [],
    // Legacy callbacks (for backward compatibility)
    onPerfectFifthEnter: [],
    onWolfFifthEnter: []
  }
};

// ============================================================================
// METRIC CALCULATION
// ============================================================================

/**
 * Calculates stability and flux metrics from MMPA features
 *
 * Stability: Measures internal order and predictability
 * - Derived from relationship.harmony (consonance) and identity.pitch (frequency)
 * - Higher values indicate more coherent, phase-conjugate states
 *
 * Flux: Measures system energy and disorder
 * - Derived from transformation.rate (flux) and potential.chaos (entropy)
 * - Higher values indicate more active/chaotic states
 *
 * @param {object} mmpaFeatures - The MMPA feature object
 * @returns {{stabilityMetric: number, fluxMetric: number}}
 */
// Debug logging state
let debugLogCounter = 0;

function calculateMetrics(mmpaFeatures) {
  // Extract feature values with safe defaults (using actual MMPA feature names)
  const consonance = mmpaFeatures.relationship?.consonance || 0;
  // Use pitch if available (from anchors), otherwise use strength (pitch clarity)
  const pitch = mmpaFeatures.identity?.pitch || mmpaFeatures.identity?.strength || 0;
  const strength = mmpaFeatures.identity?.strength || 0;  // RMS amplitude (signal presence)
  const flux = mmpaFeatures.transformation?.flux || 0;
  const entropy = mmpaFeatures.potential?.entropy || 0;

  // Debug logging every 2 seconds (120 frames at 60fps)
  debugLogCounter++;
  if (debugLogCounter % 120 === 0) {
    console.log('üîç Archetype recognizer input:', {
      consonance,
      pitch,
      strength,
      flux,
      entropy
    });
  }

  // --- STABILITY Metric Calculation ---
  // Derived from the system's internal order and predictability
  const stabilityScore =
    (consonance * 0.7) +   // Dominant weight: Harmony/Order/Consonance
    (pitch * 0.3);         // Secondary weight: Cyclic/Structural Predictability

  // Scale to ensure optimal coherent state aligns with or exceeds PHI_THRESHOLD (~1.618)
  const stabilityMetric = stabilityScore * RECOGNITION_CONFIG.STABILITY_SCALE;

  // --- FLUX Metric Calculation ---
  // Derived from the system's energy and disorder/unpredictability
  const fluxScore =
    (flux * 0.6) +         // Dominant weight: Rate of change/Energy
    (entropy * 0.4);       // Secondary weight: Disorder/Chaos

  // Normalize to 0-1.0 range
  const fluxMetric = Math.min(fluxScore * RECOGNITION_CONFIG.FLUX_NORMALIZATION, 1.0);

  return { stabilityMetric, fluxMetric, strength };
}

/**
 * Export metrics for HUD display and logging
 */
export function getMetrics(mmpaFeatures) {
  return calculateMetrics(mmpaFeatures);
}

// ============================================================================
// œÄ/œÜ CALCULATION (ANLG INPUT LAYER)
// ============================================================================

/**
 * Calculate œÄ (chaos) and œÜ (harmony) scores from MMPA features
 * This is the core of the ANLG system - maps empirical features to universal metrics
 *
 * @param {object} mmpaFeatures - The MMPA feature object
 * @returns {{pi: number, phi: number, piOverPhi: number, phiOverPi: number}}
 */
function calculatePiPhi(mmpaFeatures) {
  // Extract feature values with safe defaults
  const consonance = mmpaFeatures.relationship?.consonance || 0;
  const flux = mmpaFeatures.transformation?.flux || 0;
  const entropy = mmpaFeatures.potential?.entropy || 0;
  const strength = mmpaFeatures.identity?.strength || 0;
  const coherence = mmpaFeatures.alignment?.coherence || 0;

  // œÄ component (chaos, transcendence, transformation, unpredictability)
  // High when: Flux is high, Entropy is high, Coherence is low
  const piScore = Math.min(1, (
    (flux * 0.4) +
    (entropy * 0.3) +
    ((1 - coherence) * 0.3)
  ) * RECOGNITION_CONFIG.PI_SCALE);

  // œÜ component (harmony, order, pattern, beauty, structure)
  // High when: Consonance is high, Coherence is high, Flux is low
  const phiScore = Math.min(1, (
    (consonance * 0.4) +
    (coherence * 0.3) +
    ((1 - flux) * 0.3)
  ) * RECOGNITION_CONFIG.PHI_SCALE);

  // Calculate ratios (avoid division by zero)
  const piOverPhi = phiScore > 0.01 ? piScore / phiScore : 0;
  const phiOverPi = piScore > 0.01 ? phiScore / piScore : 10; // Default to high harmony

  // DEBUG: Log œÄ/œÜ calculation
  // console.log('üî¢ ANLG œÄ/œÜ Calculation:', {
  //   inputs: { consonance, flux, entropy, strength, coherence },
  //   scores: { pi: piScore?.toFixed(3) || '0.000', phi: phiScore?.toFixed(3) || '0.000' },
  //   ratios: { phiOverPi: phiOverPi?.toFixed(2) || '0.00', piOverPhi: piOverPhi?.toFixed(2) || '0.00' }
  // });

  return {
    pi: piScore,
    phi: phiScore,
    piOverPhi,
    phiOverPi
  };
}

/**
 * Export œÄ/œÜ metrics for external use
 */
export function getPiPhiMetrics(mmpaFeatures) {
  return calculatePiPhi(mmpaFeatures);
}

// ============================================================================
// ANLG DECISION TREE
// ============================================================================

/**
 * ANLG Layer: Get archetype from œÜ/œÄ ratio
 * This is the explicit, testable mapping from ratio to archetype
 *
 * Hypothesis: Musical consonance/dissonance maps to predictable œÜ/œÄ ratios
 * - C Major chord ‚Üí œÜ/œÄ ‚âà 4.0-9.0 ‚Üí PURE_HARMONY or HIGH_HARMONY
 * - Dissonant cluster ‚Üí œÜ/œÄ ‚âà 0.1-0.25 ‚Üí PURE_CHAOS or HIGH_CHAOS
 *
 * @param {number} phi - Harmony score (0-1)
 * @param {number} pi - Chaos score (0-1)
 * @param {number} strength - Signal strength (0-1)
 * @returns {string} Archetype name
 */
function getArchetypeFromRatio(phi, pi, strength) {
  // Silence check first (no signal = no archetype)
  if (strength < RECOGNITION_CONFIG.SILENCE_THRESHOLD) {
    console.log('üîá SILENCE DETECTED ‚Üí NEUTRAL_STATE:', {
      strength: strength?.toFixed(4) || '0.0000',
      threshold: RECOGNITION_CONFIG.SILENCE_THRESHOLD,
      isSilent: true
    });
    return ARCHETYPES.NEUTRAL_STATE;
  }

  // Calculate œÜ/œÄ ratio (avoid division by zero)
  const phiOverPi = pi > 0.01 ? phi / pi : 10; // Default to high harmony if no chaos

  let archetype;
  // ANLG Decision Tree (explicit thresholds for empirical testing)
  if (phiOverPi > RECOGNITION_CONFIG.PURE_HARMONY_THRESHOLD) {
    // œÜ/œÄ > 3.0: Dominant harmony, minimal chaos
    archetype = ARCHETYPES.PURE_HARMONY;
  } else if (phiOverPi > RECOGNITION_CONFIG.HIGH_HARMONY_THRESHOLD) {
    // œÜ/œÄ 1.5-3.0: Harmony dominates but chaos is present
    archetype = ARCHETYPES.HIGH_HARMONY;
  } else if (phiOverPi > RECOGNITION_CONFIG.BALANCED_LOWER) {
    // œÜ/œÄ 0.8-1.5: Balanced tension and resolution
    archetype = ARCHETYPES.BALANCED;
  } else if (phiOverPi > RECOGNITION_CONFIG.HIGH_CHAOS_THRESHOLD) {
    // œÜ/œÄ 0.3-0.8: Chaos dominates but harmony is present
    archetype = ARCHETYPES.HIGH_CHAOS;
  } else {
    // œÜ/œÄ < 0.3: Dominant chaos, minimal harmony
    archetype = ARCHETYPES.PURE_CHAOS;
  }

  // DEBUG: Log archetype decision
  console.log('üéØ ANLG Archetype Decision:', {
    strength: strength?.toFixed(4) || '0.0000',
    phi: phi?.toFixed(3) || '0.000',
    pi: pi?.toFixed(3) || '0.000',
    phiOverPi: phiOverPi?.toFixed(2) || '0.00',
    archetype: archetype
  });

  return archetype;
}

// ============================================================================
// ARCHETYPE EVALUATION (œÜ-Based Logic)
// ============================================================================

/**
 * Evaluates the archetypal state using œÜ-based thresholds with hysteresis
 *
 * @param {number} stabilityMetric - Coherence measure (0‚Äì2+)
 * @param {number} fluxMetric - System energy/activity (0‚Äì1)
 * @param {number} strength - RMS signal amplitude (0‚Äì1)
 * @param {string} currentArchetype - Current state (for hysteresis)
 * @returns {string} Archetype name
 */
// Debug logging state for archetype evaluation
let archetypeDebugCounter = 0;

function evaluateArchetype(stabilityMetric, fluxMetric, strength, currentArchetype) {
  // REVISED LOGIC v3 (Oct 30, 2025):
  // - Use STRENGTH (RMS amplitude) to detect presence, not flux
  // - Add 5% hysteresis to prevent flip-flopping
  // - Strict validation: PERFECT_FIFTH requires stability ‚â• œÜ

  // Calculate hysteresis-adjusted thresholds
  const hysteresis = RECOGNITION_CONFIG.HYSTERESIS_PERCENT;

  // If already in PERFECT_FIFTH, require stability to drop further before exiting
  const phiThreshold = currentArchetype === ARCHETYPES.PERFECT_FIFTH
    ? PHI_THRESHOLD * (1 - hysteresis)  // Exit: 1.537 (more lenient to stay in)
    : PHI_THRESHOLD;                     // Enter: 1.618 (standard threshold)

  // If already in WOLF_FIFTH, require flux to drop further before exiting
  const fluxThreshold = currentArchetype === ARCHETYPES.WOLF_FIFTH
    ? 0.03 * (1 - hysteresis)  // Exit: 0.0285 (more lenient to stay in)
    : 0.03;                     // Enter: 0.03 (standard threshold)

  // DEBUG LOGGING: Log every 120 frames (every 2 seconds at 60fps)
  archetypeDebugCounter++;
  if (archetypeDebugCounter % 120 === 0) {
    console.log('üîç ARCHETYPE EVALUATOR:', {
      current: currentArchetype,
      stabilityMetric: stabilityMetric.toFixed(3),
      fluxMetric: fluxMetric.toFixed(4),
      strength: strength.toFixed(4),
      phiThreshold: phiThreshold.toFixed(3),
      fluxThreshold: fluxThreshold.toFixed(4),
      checks: {
        perfectFifth: `stability(${stabilityMetric.toFixed(3)}) >= phi(${phiThreshold.toFixed(3)}) && strength(${strength.toFixed(4)}) >= 0.02 = ${stabilityMetric >= phiThreshold && strength >= 0.02}`,
        silence: `strength(${strength.toFixed(4)}) < 0.01 = ${strength < 0.01}`,
        wolfFifth: `flux(${fluxMetric.toFixed(4)}) >= ${fluxThreshold.toFixed(4)} && stability(${stabilityMetric.toFixed(3)}) < ${PHI_THRESHOLD.toFixed(3)} = ${fluxMetric >= fluxThreshold && stabilityMetric < PHI_THRESHOLD}`
      }
    });
  }

  // 1. High Coherence ‚Üí Perfect Fifth (Ringing Bell)
  // A sustained, coherent tone (pure sine, ringing bell, harmonic music)
  // STRICT: Requires stability ‚â• œÜ threshold AND audible signal (strength ‚â• 0.02)
  if (stabilityMetric >= phiThreshold && strength >= 0.02) {
    if (archetypeDebugCounter % 120 === 0) {
      console.log('üîç ‚Üí Decision: PERFECT_FIFTH (high coherence + audible)');
    }
    return ARCHETYPES.PERFECT_FIFTH;
  }

  // 2. Very Quiet Field ‚Üí Neutral (Aether)
  // True silence or near-silence (strength < 0.01)
  if (strength < 0.01) {
    if (archetypeDebugCounter % 120 === 0) {
      console.log('üîç ‚Üí Decision: NEUTRAL_STATE (silence)');
    }
    return ARCHETYPES.NEUTRAL_STATE;
  }

  // 3. Active Chaos ‚Üí Wolf Fifth (Cracked Bell)
  // High activity/change but low coherence (noise, dissonance, transients)
  // STRICT: Requires flux ‚â• threshold AND stability < œÜ (to prevent overlap with Perfect Fifth)
  if (fluxMetric >= fluxThreshold && stabilityMetric < PHI_THRESHOLD) {
    if (archetypeDebugCounter % 120 === 0) {
      console.log('üîç ‚Üí Decision: WOLF_FIFTH (high flux + low stability)');
    }
    return ARCHETYPES.WOLF_FIFTH;
  }

  // 4. Moderate/Transitional States ‚Üí Neutral
  // Some signal present but neither coherent nor chaotic
  if (archetypeDebugCounter % 120 === 0) {
    console.log('üîç ‚Üí Decision: NEUTRAL_STATE (default/transitional)');
  }
  return ARCHETYPES.NEUTRAL_STATE;
}

/**
 * Main recognition function (ANLG-based œÄ/œÜ system)
 *
 * @param {object} mmpaFeatures - Current MMPA feature state
 * @returns {object} Recognition result
 */
export function recognizeArchetype(mmpaFeatures) {
  // Calculate œÄ/œÜ metrics using ANLG system
  const { pi, phi, piOverPhi, phiOverPi } = calculatePiPhi(mmpaFeatures);
  const strength = mmpaFeatures.identity?.strength || 0;

  // Store œÄ/œÜ values for external access
  recognitionState.lastPi = pi;
  recognitionState.lastPhi = phi;
  recognitionState.lastPhiOverPi = phiOverPi;

  // Legacy metrics (for backward compatibility with old HUD displays)
  const { stabilityMetric, fluxMetric } = calculateMetrics(mmpaFeatures);
  recognitionState.lastStabilityMetric = stabilityMetric;
  recognitionState.lastFluxMetric = fluxMetric;

  // Evaluate archetype using ANLG decision tree
  const detectedArchetype = getArchetypeFromRatio(phi, pi, strength);

  // Debug: Log œÄ/œÜ values during archetype changes
  // Don't log during silence (would show stale/cached values)
  if (detectedArchetype !== recognitionState.currentArchetype) {
    // Only log if we have actual signal (not transitioning to/from silence)
    if (strength >= RECOGNITION_CONFIG.SILENCE_THRESHOLD) {
      // console.log(`üéØ ANLG evaluation - œÜ/œÄ: ${phiOverPi.toFixed(3)}, œÄ: ${pi.toFixed(3)}, œÜ: ${phi.toFixed(3)}, strength: ${strength.toFixed(4)}`);
    }
  }

  // Calculate confidence based on how definitively the archetype is determined
  let confidence = 0;
  if (detectedArchetype === ARCHETYPES.PURE_HARMONY) {
    // Confidence increases with œÜ/œÄ ratio above threshold
    confidence = Math.min((phiOverPi - RECOGNITION_CONFIG.PURE_HARMONY_THRESHOLD) / 2.0 + 0.7, 1.0);
  } else if (detectedArchetype === ARCHETYPES.HIGH_HARMONY) {
    // Confidence is high in the middle of the range
    const midpoint = (RECOGNITION_CONFIG.PURE_HARMONY_THRESHOLD + RECOGNITION_CONFIG.HIGH_HARMONY_THRESHOLD) / 2;
    const distance = Math.abs(phiOverPi - midpoint);
    confidence = Math.max(0.5, 1.0 - distance);
  } else if (detectedArchetype === ARCHETYPES.BALANCED) {
    // Confidence is highest near œÜ/œÄ = 1.0 (perfect balance)
    const distance = Math.abs(phiOverPi - 1.0);
    confidence = Math.max(0.4, 1.0 - distance * 2);
  } else if (detectedArchetype === ARCHETYPES.HIGH_CHAOS) {
    // Confidence is high in the middle of the range
    const midpoint = (RECOGNITION_CONFIG.HIGH_CHAOS_THRESHOLD + RECOGNITION_CONFIG.BALANCED_LOWER) / 2;
    const distance = Math.abs(phiOverPi - midpoint);
    confidence = Math.max(0.5, 1.0 - distance);
  } else if (detectedArchetype === ARCHETYPES.PURE_CHAOS) {
    // Confidence increases as œÜ/œÄ approaches zero
    confidence = Math.min((RECOGNITION_CONFIG.HIGH_CHAOS_THRESHOLD - phiOverPi) / 0.3 + 0.7, 1.0);
  } else {
    // Neutral: confidence based on silence depth
    confidence = Math.max(0, 1.0 - (strength / RECOGNITION_CONFIG.SILENCE_THRESHOLD));
  }

  recognitionState.confidence = confidence;

  // Update history
  recognitionState.history.push({
    archetype: detectedArchetype,
    confidence: confidence,
    pi: pi,
    phi: phi,
    phiOverPi: phiOverPi,
    stabilityMetric: stabilityMetric,  // Legacy
    fluxMetric: fluxMetric,  // Legacy
    timestamp: performance.now()
  });

  // Trim history
  if (recognitionState.history.length > RECOGNITION_CONFIG.HISTORY_LENGTH) {
    recognitionState.history.shift();
  }

  // Check for archetype transition (with cooldown to prevent flicker)
  const now = performance.now();
  const timeSinceLastTransition = now - recognitionState.lastTransitionTime;

  if (detectedArchetype !== recognitionState.currentArchetype &&
      timeSinceLastTransition > RECOGNITION_CONFIG.TRANSITION_COOLDOWN) {
    handleArchetypeTransition(detectedArchetype, confidence, pi, phi, phiOverPi);
  }

  return {
    archetype: recognitionState.currentArchetype,
    confidence: recognitionState.confidence,
    pi: pi,
    phi: phi,
    phiOverPi: phiOverPi,
    stabilityMetric: stabilityMetric,  // Legacy
    fluxMetric: fluxMetric,  // Legacy
    transitionInProgress: recognitionState.transitionInProgress
  };
}

// ============================================================================
// TRANSITION HANDLING
// ============================================================================

/**
 * Handle transition to a new archetype (ANLG-based)
 */
function handleArchetypeTransition(newArchetype, confidence, pi, phi, phiOverPi) {
  const oldArchetype = recognitionState.currentArchetype;

  console.log(
    `üîÑ ANLG Transition: ${oldArchetype} ‚Üí ${newArchetype} ` +
    `(œÜ/œÄ: ${phiOverPi.toFixed(3)}, œÄ: ${pi.toFixed(3)}, œÜ: ${phi.toFixed(3)}, ` +
    `confidence: ${(confidence * 100).toFixed(1)}%)`
  );

  recognitionState.previousArchetype = oldArchetype;
  recognitionState.currentArchetype = newArchetype;
  recognitionState.transitionInProgress = true;
  recognitionState.lastTransitionTime = performance.now();

  // Trigger callbacks
  triggerCallbacks('onArchetypeChange', {
    from: oldArchetype,
    to: newArchetype,
    confidence,
    pi,
    phi,
    phiOverPi
  });

  // Trigger specific archetype callbacks (ANLG system)
  if (newArchetype === ARCHETYPES.PURE_HARMONY) {
    // console.log(`‚ú®üíé PURE HARMONY - Perfect Consonance (œÜ/œÄ: ${phiOverPi.toFixed(3)} > ${RECOGNITION_CONFIG.PURE_HARMONY_THRESHOLD})`);
    triggerCallbacks('onPureHarmonyEnter', { confidence, pi, phi, phiOverPi });
    // Legacy callback for backward compatibility
    triggerCallbacks('onPerfectFifthEnter', { confidence, pi, phi, phiOverPi });
  } else if (newArchetype === ARCHETYPES.HIGH_HARMONY) {
    console.log(`‚ú® HIGH HARMONY - Strong Consonance (œÜ/œÄ: ${phiOverPi.toFixed(3)})`);
    triggerCallbacks('onHighHarmonyEnter', { confidence, pi, phi, phiOverPi });
  } else if (newArchetype === ARCHETYPES.BALANCED) {
    // console.log(`‚öñÔ∏è BALANCED - Harmony/Chaos Equilibrium (œÜ/œÄ: ${phiOverPi.toFixed(3)})`);
    triggerCallbacks('onBalancedEnter', { confidence, pi, phi, phiOverPi });
  } else if (newArchetype === ARCHETYPES.HIGH_CHAOS) {
    console.log(`‚ö° HIGH CHAOS - Strong Dissonance (œÜ/œÄ: ${phiOverPi.toFixed(3)})`);
    triggerCallbacks('onHighChaosEnter', { confidence, pi, phi, phiOverPi });
  } else if (newArchetype === ARCHETYPES.PURE_CHAOS) {
    console.log(`üí•‚ö° PURE CHAOS - Wolf Fifth Crisis (œÜ/œÄ: ${phiOverPi.toFixed(3)} < ${RECOGNITION_CONFIG.HIGH_CHAOS_THRESHOLD})`);
    triggerCallbacks('onPureChaosEnter', { confidence, pi, phi, phiOverPi });
    // Legacy callback for backward compatibility
    triggerCallbacks('onWolfFifthEnter', { confidence, pi, phi, phiOverPi });
  } else if (newArchetype === ARCHETYPES.NEUTRAL_STATE) {
    console.log(`üå´Ô∏è NEUTRAL STATE - Silence/Aether (œÜ/œÄ: ${phiOverPi.toFixed(3)})`);
    triggerCallbacks('onNeutralStateEnter', { confidence, pi, phi, phiOverPi });
  }

  // Transition completes after a delay
  setTimeout(() => {
    recognitionState.transitionInProgress = false;
  }, RECOGNITION_CONFIG.TRANSITION_COOLDOWN);
}

// ============================================================================
// EVENT SYSTEM
// ============================================================================

/**
 * Register a callback for archetype events
 * @param {string} event - Event name
 * @param {function} callback - Callback function
 */
export function onArchetypeEvent(event, callback) {
  if (recognitionState.callbacks[event]) {
    recognitionState.callbacks[event].push(callback);
  }
}

/**
 * Trigger all callbacks for an event
 */
function triggerCallbacks(event, data) {
  if (recognitionState.callbacks[event]) {
    recognitionState.callbacks[event].forEach(callback => callback(data));
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Get the current archetype
 */
export function getCurrentArchetype() {
  // Check if synth is active - use pitch-based archetype mapping
  if (isSynthMode()) {
    const synthArchetype = getSynthArchetype();
    if (synthArchetype) {
      return synthArchetype;
    }
  }

  // Otherwise use normal ANLG spectrum analysis
  return recognitionState.currentArchetype;
}

/**
 * Get the current confidence level
 */
export function getConfidence() {
  return recognitionState.confidence;
}

/**
 * Get the current stability metric (œÜ-coherence)
 */
export function getStabilityMetric() {
  return recognitionState.lastStabilityMetric;
}

/**
 * Get the current flux metric (system activity)
 */
export function getFluxMetric() {
  return recognitionState.lastFluxMetric;
}

/**
 * Check if a specific archetype is active
 */
export function isArchetype(archetype) {
  return recognitionState.currentArchetype === archetype;
}

/**
 * Get recognition history
 */
export function getRecognitionHistory() {
  return [...recognitionState.history];
}

/**
 * Get archetype stability (how consistently the same archetype has been detected)
 */
export function getArchetypeStability(frames = 30) {
  if (recognitionState.history.length < frames) {
    return 0;
  }

  const recent = recognitionState.history.slice(-frames);
  const currentArchetype = recognitionState.currentArchetype;
  const matches = recent.filter(r => r.archetype === currentArchetype).length;

  return matches / frames;
}

/**
 * Reset recognition state
 */
export function resetRecognition() {
  recognitionState.currentArchetype = ARCHETYPES.NEUTRAL_STATE;
  recognitionState.previousArchetype = null;
  recognitionState.confidence = 0;
  recognitionState.lastStabilityMetric = 0;
  recognitionState.lastFluxMetric = 0;
  recognitionState.transitionInProgress = false;
  recognitionState.history = [];

  console.log("üîç Archetype recognition reset");
}

/**
 * Update calibration factors (for tuning during testing)
 */
export function updateCalibration(stabilityScale, fluxNormalization) {
  if (stabilityScale !== undefined) {
    RECOGNITION_CONFIG.STABILITY_SCALE = stabilityScale;
    console.log(`üîß Stability scale updated to ${stabilityScale}`);
  }
  if (fluxNormalization !== undefined) {
    RECOGNITION_CONFIG.FLUX_NORMALIZATION = fluxNormalization;
    console.log(`üîß Flux normalization updated to ${fluxNormalization}`);
  }
}

console.log("üîç archetypeRecognizer.js ready - œÜ-Based Pattern Recognition (œÜ = " + PHI_THRESHOLD.toFixed(5) + ")");
